%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tufte-Style Book (Minimal Template)
% LaTeX Template
% Version 1.0 (5/1/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% IMPORTANT NOTE:
% In addition to running BibTeX to compile the reference list from the .bib
% file, you will need to run MakeIndex to compile the index at the end of the
% document.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{tufte-book} % Use the tufte-book class which in turn uses the tufte-common class

\usepackage{microtype} % Improves character and word spacing
\usepackage{amsmath}
\usepackage{booktabs} % Better horizontal rules in tables
\usepackage[tikz]{bclogo}

%\usepackage{Sweave}
\usepackage{float}
\usepackage{graphicx} % Needed to insert images into the document 
\graphicspath{{graphics/}} % Sets the default location of pictures
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio} % Improves figure scaling
\usepackage{fancyvrb} % Allows customization of verbatim environments
\fvset{fontsize=\normalsize} % The font size of all verbatim text can be changed here

\newcommand{\hangp}[1]{\makebox[0pt][r]{(}#1\makebox[0pt][l]{)}} % New command to create parentheses around text in tables which take up no horizontal space - this improves column spacing
\newcommand{\hangstar}{\makebox[0pt][l]{*}} % New command to create asterisks in tables which take up no horizontal space - this improves column spacing

\usepackage{xspace} % Used for printing a trailing space better than using a tilde (~) using the \xspace command

\newcommand{\monthyear}{\ifcase\month\or January\or February\or March\or April\or May\or June\or July\or August\or September\or October\or November\or December\fi\space\number\year} % A command to print the current month and year


\newcommand{\blankpage}{\newpage\hbox{}\thispagestyle{empty}\newpage} % Command to insert a blank page

\newcommand{\newfun}[1]{\begin{LARGE} \begin{center} \texttt{#1} \end{center} \end{LARGE}}
\setcounter{tocdepth}{1}
\usepackage{makeidx} % Used to generate the index
\makeindex % Generate the index which is printed at the end of the document

%----------------------------------------------------------------------------------------
%	BOOK META-INFORMATION
%----------------------------------------------------------------------------------------

\title{YaRrr! The Pirate's Guide to R}

\author{Dr. Nathaniel D. Phillips}

%\publisher{Publisher Name}

%----------------------------------------------------------------------------------------

\begin{document}

% \begin{center}
% \includegraphics[width=40cm]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/YaRrr_Cover.pdf}
% \end{center}
% 


\frontmatter

\maketitle

%----------------------------------------------------------------------------------------
%	COPYRIGHT PAGE
%----------------------------------------------------------------------------------------

\newpage
\begin{fullwidth}
~\vfill
\thispagestyle{empty}
\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}
Copyright \copyright\ \the\year\ \thanklessauthor

\par\smallcaps{Published by \thanklesspublisher}

\par\smallcaps{\url{http://www.nathanieldphillips.com}}

\par This document may not be used for any commercial purposes. All rights are reserved by Nathaniel Phillips.\index{license}

\par\textit{First printing, \monthyear}
\end{fullwidth}

%----------------------------------------------------------------------------------------

\tableofcontents % Print the table of contents

%----------------------------------------------------------------------------------------

%\listoffigures % Print a list of figures

%----------------------------------------------------------------------------------------

%\listoftables % Print a list of tables

%----------------------------------------------------------------------------------------
%	DEDICATION PAGE
%----------------------------------------------------------------------------------------

\cleardoublepage
~\vfill
\begin{doublespace}
\noindent\fontsize{18}{22}\selectfont\itshape
\nohyphenation
This book is dedicated to my former statistics instructors Dr. Thomas Moore and Dr. Wei Lin who taught me everything I know about statistics, and my PhD colleagues Dr. Dirk Wulff and Dr. Stefan Herzog who taught me everything I know about R.
\end{doublespace}
\vfill
\vfill


%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

%\cleardoublepage

\chapter{Introduction} % The asterisk leaves out this chapter from the table of contents

\subsection{Who am I?}

I am a pirate on the Bodensee in Konstanz Germany. When I started pirate training, I discovered R and have been hooked ever since. I'm now on a mission to convince everyone I can to make the switch from SPSS (or Excel, Matlab, JMP...) to R.

\subsection{This book is in progress..}

If you haven't figured it out already, this book is very much a work in progress. I'm constantly experimenting with the material and the layout. If you have any recommendations for changes or spot any errors, please write me at YaRrr.Book@gmail.com or tweet me @YaRrrBook

\marginnote{Email me with comments, recommendations or typos at: YaRrr.Book@gmail.com or tweet me at @YaRrrBook}

\subsection{Who is this book for?}
Anyone who wants to learn R can benefit from this book. I will assume that you have taken an introductory course in statistics, but have no substantial programming experience. While the techniques in this book apply to most data analysis problems, because my background is in experimental psychology I will cater the course to solving analysis problems commonly faced in psychological research.

\subsection{What this book \textbf{is}}

This book is meant to introduce you to the basic analytical tools in R, from basic coding and analyses, to data wrangling, plotting, and statistical inference.

\subsection{What this book is \textbf{not}}

This book does not cover any one topic in extensive detail. If you are interested in conducting analyses or creating plots not covered in the book, I'm sure you'll find the answer with a quick Google search!

\subsection{Why is R so great?}

As you've already gotten this book, you probably already have some idea why R is so great. However, in order to help prevent you from giving up the first time you run into a programming wall, let me give you a few more reasons:

\begin{enumerate}

\item R is 100\% free and as a result, has a huge support community. Unlike SPSS, Matlab, Excel and JMP, R is, and always will be completely free. This doesn't just help your wallet - it means that a huge community of R programmers will constantly develop an distribute new R functionality and packages at a speed that leaves all those other packages in the dust! Unlike Fight Club, the first rule of R is "Do talk about R!" The size of the R programming community is staggering. If you ever have a question about how to implement something in R, a quick Poogle\footnote{I am in the process of creating Poogle - Google for Pirates. Kickstarter page coming soon...} search will lead you to your answer virtually every single time.

\item R is incredibly versatile. You can use R to do everything from calculating simple summary statistics, to performing complex simulations to creating gorgeous plots like the chord diagram in Figure~\ref{fig:chorddiagram}. If you can imagine an analytical task, you can almost certainly implement it in R.

\begin{marginfigure}
\begin{tiny}
<<>>=
require("circlize")
mat = matrix(sample(1:100, 18, replace = TRUE), 3, 6)
rownames(mat) = letters[1:3]
colnames(mat) = LETTERS[1:6]
chordDiagram(mat)
@
\end{tiny}
\caption{This is a \texttt{chordDiagram} plot that comes with the R package \texttt{circlize}.}
\label{fig:chorddiagram}
\end{marginfigure}


\item Using RStudio, You can easily and seamlessly combine R code, analyses, plots, and written text into elegant documents all in one place using Sweave (R and Latex) or RMarkdown. In fact, I wrote this entire book (the text, formatting, plots, code...yes, everything) in RStudio using Sweave. With RStudio and Sweave, instead of trying to manage two or three programs, say Excel, Word and (sigh) SPSS, where you find yourself spending half your time copying, pasting and formatting data, images and test, you can do everything in one place so nothing gets misread, mistyped, or forgotten.

\item Analyses conducted in R are transparent, easily shareable, and reproducible. If you ask an SPSS user how they conducted a specific analyses, they will either A) Not remember,  B) Try (nervously) to construct an analysis procedure on the spot that makes sense - which may or may not correspond to what they actually did months or years ago, or C) Ask you what you are doing in their kitchen\footnote{Get used to the bad jokes people. Lots more where that came from.}. I used to primarily use SPSS, so I speak from experience on this. If you ask an R user (who uses good programming techniques!) how they conducted an analysis, they should always be able to show you the exact code they used. Of course, this doesn't mean that they used the appropriate analysis or interpreted it correctly, but with all the original code, any problems should be completely transparent!

\item And most importantly of all, R is the programming language of choice for pirates, (who prefer the "YaRrr!" pronunciation)

\end{enumerate}

\subsection{Code Chunks}

In this book, R code is (almost) always presented in a separate gray box like this one:

\begin{footnotesize}
<<>>=
a <- 1 + 2 + 3 + 4 + 5
a
@
\end{footnotesize}

This is called a \textit{code chunk}. You should always be able to directly copy and paste code chunks directly into R. If you copy a chunk and it does not work for you, it is most likely because the code refers to a package, function, or object that I defined in a previous chunk. If so, read back and look for a previous chunk that contains the missing definition. As you'll soon learn, lines that begin with \texttt{\#} are either comments or output from prior code that R will ignore.

As you'll notice, I'll include code chunks before all plots in the book. In early chapters, the code might not make sense just yet. However, I elected to always include plotting code so you have the option of re-creating (and tweaking) any plot in the book.

\subsection{Additional Tips}

Because this is a beginner's book, I try to avoid bombarding you with too many details and tips when I first introduce a function. For this reason, at the end of every chapter, I present several tips and tricks that I think most R users should know once they get comfortable with the basics. I highly encourage you to read these additional tips as I expect you'll find at least some of them very useful if not invaluable.


\mainmatter


%----------------------------------------------------------------------------------------
%	CHAPTER 1
%----------------------------------------------------------------------------------------
\chapter{1: Installing R, RStudio, and the pirate dataset}
\label{ch:1}

%------------------------------------------------

Now that I've convinced you to use R, let's get started! First, you'll need to install the base R software.

1. Download and install the base R software (around 50mb)
    + Windows <http://cran.r-project.org/bin/windows/base/>
    + Mac <http://cran.r-project.org/bin/macosx/>

See Figure \ref{fig:rscreenshot} Here's how the base R software looks (on Mac). As you can see, it's very much a bare-bones software - just how we want it! No extra gimmicks or flashy bloatware needed!

\begin{marginfigure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/RScreenshot.png}
\caption{Here is how the standard R application looks. Not too exciting - just how we like it!}
\label{fig:rscreenshot}
\end{marginfigure}

While you can do pretty much everything you want within base R, you'll find that most people these days do their R programming in an application called RStudio. RStudio is a graphical user interface (GUI)-like interface for R that makes programming in R a bit easier. To download and install RStudio (around 40mb), go to <http://www.rstudio.com/products/rstudio/download/>

Once you've installed RStudio, you'll never need to open the base R application. Let's go ahead and boot up RStudio and see how she looks!

\subsection{The four RStudio windows}

When you open RStudio, you'll see the following four windows (also called panes):

\begin{figure*}[h]
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/RStudio_Screenshot_Labels.png}
\caption{The four panes of RStudio.}
\label{fig:fullfig}
\end{figure*}

Note your windows might be in a different order. You can change the order of the windows under RStudio preferences.

\subsection{Source - Your notepad for code}

The source pane is where you create and edit R Scripts - which are just text files with the ".R" extension. When you open RStudio, it will automatically start a new Untitled script. You will write 99\% of your R code in a script in the source panel. However, your R code will not be evaluated until you 'send' the code to the Console.

You can send your code from the source to the Console by highlighting the code you wish to evaluate and clicking on the "Run" button on the top right of the Source. Alternatively, you can use the hot-key "Command + Return" on Mac, or "Control + Enter" on PC to send code to the console.



\subsection{Console: The calculator}

The console is where R actually executes (calculates) code. You can type code directly into the console and get an immediate response. For example, if you type 1+1 into the console, you'll see that R immediately gives an output of 2

\begin{footnotesize}
<<>>=
1+1
@
\end{footnotesize}

\marginnote{Tip: Try to write most of your code in a document in the Source. Only type directly into the Console to de-bug or do quick analyses.}

However, most of the time, you won't be typing directly into the console. Instead, you'll be writing code in the source and then "Running" it to the console. The reason for this is straightforward: If you type code into the console, it won't be saved (though you can look back on your command History). And if you make a mistake in typing code into the console, you'd have to re-type everything all over again. Instead, it's better to write all your code in the Source. When you are ready to execute some code, you can then send "Run" it to the console.

\subsection{Environment / History}

The Environment tab of this panel shows you the names of all the data objects (like vectors, matrices, and dataframes) that you've defined in your current R session. The tab also has a few clickable actions like importing a new dataset. However, I almost never look at this menu.

The History tab of this panel simply shows you a history of your R commands. I never look at this. In fact, I didn't realize it was even there until I started writing this tutorial.

\subsection{Files / Plots / Packages / Help}

This panel shows you file directories, plots, your current packages, and help menus.

\begin{enumerate}
\item Files - Gives you access to the file directory on your harddrive. One nice feature of the "Files" panel is that you can use it to set your working directory - once you navigate to a folder you want to read and save files to, click "More" and then "Set As Working Directory."
\item Plots - Shows your plots. There are buttons for opening the plot in a separate window and exporting the plot as a pdf or jpeg (though you can also do this with code using the \texttt{pdf()} or \texttt{jpeg()} functions.)\marginnote{Most - if not all - of the time when you perform actions using your mouse by pointing and clicking in RStudio, RStudio will perform the function by sending the appropriate R Code to the console. You can then copy and paste this code into your documents to automate the process later.}
\item Packages - Shows a list of all the R packages installed on your harddrive and indicates whether or not they are currently loaded. Packages that are loaded in the current session are checked while those that are installed but not yet loaded are unchecked.
\item Help - Help menu for R functions. You can either type the name of a function in the search window, or use the code \texttt{?function.name} to search for a function with the name \texttt{function.name}
\end{enumerate}


To see how plots are displayed try the following command which should display a histogram of 100 values randomly drawn from a standard normal distribution.

\begin{footnotesize}
<<fig.width = 4, fig.height = 4>>=
hist(x = rnorm(n = 100, mean = 1000, sd = 100),
     main = "Plunder in 2015",
     xlab = "Amount"
     )
@
\end{footnotesize}

\section{Getting help}

To get help and see documentation for a function, type \texttt{?fun}, where \texttt{fun} is the name of the function. For example, to get additional information on the histogram function, run the following code:

\marginnote{Tip: If you ever need to learn more about an R function: type \texttt{?functionname}, where \texttt{functionname} is the name of the function.}

\begin{footnotesize}
<<eval = F>>=
?hist
@
\end{footnotesize}


\section{Installing and loading packages}

When you download and install R for the first time, you are installing the Base R software. Base R will will contain most if not all the functions you need. However, one of the great things about R is that people are constantly writing and sharing new functions that you can use. When people share a new function, they usually do so in the form of an \textit{R package} which contains anything from functions, to help menus, to vignettes (examples), to data. To install a new R package, you need to run the code \texttt{install.packages("package")}, where "package" is the name of the package. After you've installed the package, you need to \textit{load} it into R by running the code \texttt{load("package)}. This will load the package into your current R session and allow you to use its contents.\marginnote{Once you've installed a package on your computer, you never need to install it again. However, you do need to load the package every time you start a new R session.}

For example, let's say you want to create a wordcloud - a graph that plots text in different sizes. You can certainly program this yourself in R, but thankfully someone has created a package called \texttt{wordcloud} with a function that will do this for you. Let's install the package, load it, and then use the \texttt{wordcloud} function:

\begin{footnotesize}
<<fig.width = 3, fig.height = 3, prompt=FALSE, warning=FALSE>>=
install.packages("wordcloud")
library("wordcloud") # Install the package

par(mar = rep(0, 4))
wordcloud(words = c("sword", "YaRrr!", "eyepatch", 
                    "parrot", "plunder", "treasure",
                    "chest", "scurvy"),
          freq = sample(50:1000, 8), 
          colors = gray(runif(8, 0, 1)))
@
\end{footnotesize}



\section{Downloading and loading the pirate dataset}

For much of this book, we will be referring to the \texttt{pirate} dataset. This dataset contains the results of a survey completed by 1,000 pirates that have been on my crew. To download this dataset, execute the following code:

<<>>=
pirates <- read.table(file = "http://nathanieldphillips.com/wp-content/uploads/2015/05/pirate_survey.txt",
           header = T,
           sep = "\t",
           stringsAsFactors = F
           )
@

If you'd like to see how the dataset looks, you can execute the \texttt{View()} function:

<<eval = FALSE>>=
View(pirates)
@

When you run this command, you should see the first several rows and columns of the dataset (like this:)

\begin{figure*}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/pirates_data_screenshot.png}
\caption{The pirates dataset.}
\label{fig:piratesdata}
\end{figure*}



\section{The R Reference Card}

Over the course of this book, you will be learning \textit{lots} of new functions. Wouldn't it be nice if someone created a Cheatsheet / Notecard of many common R functions? Yes it would, and thankfully Tom Short has done this in his creation of the R Reference Card. You can download a copy at <https://dl.dropboxusercontent.com/u/7618380/RReferenceCard.pdf>. I highly encourage you to print this out and start highlighting functions as you learn them!


\subsection{Finished!}

That's it for this lecture! All you did was install the most powerful statistical package on the planet used by top universities and companies like Google. No big deal.

%----------------------------------------------------------------------------------------
%	CHAPTER 2
%----------------------------------------------------------------------------------------

\chapter{2: Coding Basics}
\label{ch:2}


\subsection{Chapter Goals}

\begin{enumerate}
  \item Accept that learning R will take time (and promise you'll never go back to SPSS!)
  \item Know how to use comments and spaces in R code.
  \item Be able to define and manipulate scalars and vectors
  \item Generate vectors using c(), :, rep(), and seq()
\end{enumerate}


\subsection{Before we get started, a word of warning...}

So by now you've installed R and you're ready to get started. But first, let me give you a brief word of warning: Especially if this is your first experience programming, you are going to experience a \textit{lot} of headaches when you get started. You will run into error after error and pound your fists against the table screaming: "WHY ISN'T MY CODE WORKING?!?!? There must be something wrong with this stupid software!!!" You will spend hours trying to find a bug in your code, only to find that - frustratingly enough, you had had an extra space or missed a comma somewhere. You'll then wonder why you ever decided to learn R when (::sigh::) SPSS was so "nice and easy."


\marginnote{Fun fact: SPSS stands for "Shitty Piece of Shitty Shit". True story.}

This is perfectly normal! Don't get discouraged and DON'T GO BACK TO SPSS! Trust me, as you gain more programming experience, you'll experience fewer and fewer bugs (though they'll never go away completely). Once you get over the initial barriers, you'll find yourself conducting analyses much, much faster than you ever did before.

\subsection{The basics of R programming}

Ok, let's write some code! Again, we will write all our code in a script file in the Source pane of RStudio. When we want to execute it, we'll send it to the Console.

\subsection{R as a calculator}

At its heart, R is just a fancy calculator. Let's do some basic algebra, type the following command into the source, then highlight the text and click "Run" to execute it in the console:

\marginnote{Tip: To execute code from the source to the console, highlight it and use the hot-keys "Command-Return" on Mac or "Control-Enter" on PC.}


<<>>=
1+1 # The result should be 2
@


As you can see, R returns the (thankfully correct) value of 2. You'll notice that the console also returns the text [1]. This is just telling you you the index of the value next to it. Don't worry about this for now, it will make more sense later.

Additionally, you'll notice that I included a comment in the code using the \# sign. R will ignore everything on a line after the \# sign. So why do we use comments? Mainly to explain to others, including your future self, what you are trying to do with your code.\marginnote{Do your future self a favor and use comments to explain what you're doing with your code. Also, maybe go for a run once in a while.}

Let's try some more simple calculations


<<>>=
2 * 3 - 1 # R ignores spaces
2 * (3 - 1) # R observes order of operations
@


As you can see, R ignores spaces in between arguments in code. I recommend using spaces to make your code easier to look at. Personally, I include spaces between arithmetic operators (like + and -) and after commas (which we'll get to later).

\section{Defining objects with the <- assignment}

\marginnote{Good object names strike a balance between being easy to type (i.e.; short names) and interpret. If you have several datasets, it's probably not a good idea to name them \texttt{a}, \texttt{b}, \texttt{c} because you'll forget which is which. However, using long names like \texttt{March2015Group1OnlyFemales} and \texttt{March2015Group1OnlyMales} will give you carpel tunnel syndrome.}

So far so good, you can use R as a simple calculator. Now, let's do our first \textit{object assignment}. Object assignment is our way of storing information, such as a number or a statistical test, into something we can easily refer to later. Let's start by creating the object "mateys" and assigning the outcome of $5*10}$ to it:


<<>>=
# The symbol(s) "<-" mean "assign"
mateys <- 5 * 10 # Assign the value of 5*10 to a new objected called mateys
@

Now, anytime we want to refer to the content of the object \texttt{mateys}, we can just type it. When you assign a value to an object, R won't automatically print it. If you want to see the value, you need to call the object by just executing its name:


<<>>=
mateys # What is the value of mateys?
@


A few notes about defining objects: you can't start the name of an object with a number, and you can't have spaces or other 'weird' characters in the name. Here are some examples of \textit{invalid} object names:


<<eval = F>>=
me mateys <- 50 # Can't have spaces
5.mateys <- 50 # Can't start a name with a number
mayeys! <- 5 0# Can't have an "!" in the object name
@


R is case-sensitive. If you define an object with uppercase letters, you must keep referring to it with uppercase letters!

\marginnote{Avoid using too many capital letters in object names because they require you to hold the shift key. This may sound silly, but you'd be surprised how much easier it is to type \texttt{mydata} than \texttt{MyData} 100 times.}


<<>>=
Plunder <- 1
plunder <- 100
Plunder
plunder
@


Once you've defined an object, you can use it in other commands:

<<>>=
a <- 100
b <- 2
c <- a + b
c
@


If you want to change an object, you can just reassign it. You can even refer to the same object when reassigning it:


<<>>=
a <- 2
a <- a + a
a
@


\marginnote{You can use \texttt{=} instead of \texttt{<-} for object assignment but I recommend you stick with \textt{<-} because the direction of the assignment is clear.}


\section{Data object types in R}

R stores everything as an object, and there are different types of objects. The first two objects we'll learn about are scalars and vectors. Later on, we'll talk about more complicated objects like matrices, dataframes, hypothesis tests, etc.

\subsection{Two simple data objects: scalars and vectors}

Two of the most common data objects in R are \textbf{scalars} and \textbf{vectors}. Let's discuss each in turn,

\subsection{scalars}

A \textbf{scalar} is just a single value. A scalar can either be \textit{numeric} or \textit{string}. A numeric scalar is a number, while a string scalar is a letter. We denote string scalars by using quotation marks. Here are some examples:

<<>>=
a <- 1
b <- 3 * 40
ship <- "Black Pearl"
@



\begin{marginfigure}
\begin{tiny}
<<fig.height = 4, fig.width = 3>>=
# scalar v vector v matrix  

par(mar = rep(1, 4))
plot(1, xlim = c(0, 4), ylim = c(-.5, 5), 
     xlab = "", ylab = "", 
     xaxt = "n", yaxt = "n", 
     bty = "n", type = "n")

# scalar
rect(rep(0, 1), rep(0, 1), rep(1, 1), rep(1, 1))
text(.5, -.5, "scalar")

# Vector
rect(rep(2, 5), 0:4, rep(3, 5), 1:5)
text(2.5, -.5, "Vector")

@
\caption{Visual depiction of a scalar and vector. Deep shit. Wait until we get to matrices - you're going to lose it.}
\label{fig:scalarvector}
\end{tiny}
\end{marginfigure}

It is important to note that once you've defined an object, you refer to it without quotation marks, even if the object is a character. For example, to refer to the object \texttt{ship} that I defined above, you need to write \texttt{ship} without quotations marks


<<>>=
ship # Print the value of the object ship
"ship" # R thinks this is a new string called "ship", not the object called ship
@


\subsection{Vectors}

A \textbf{vector} is a combination of several scalars. For example, the numbers from one to ten could be a vector of length 10. Like scalars, you can also create character vectors that contain character scalars.


There are many ways to create vectors in R, here are the most common:

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{c(a, b, c, ...)}\index{c()}

\hline

\begin{description}

  \item[\tt{a, b, c, ...}] \hfill \\
      One or more objects to be combined into a vector
\end{description}

}
}
\vspace{5mm} %5mm vertical space


The simplest way to create a vector is with the \texttt{c()} function. The c here stands for concatenate, which means "bring them together". When using c(), place a comma in between the objects (scalers or vectors) you want to combine:

\marginnote{\texttt{c(x, y, z)}: Create a vector with the c() command by separating elements with commas}

The following code will create a vector of the integers from 1 to 5:

<<>>=
v <- c(1, 2, 3, 4, 5)
v
@

You can also create vectors by combining objects you have already defined. Let's create a vector of the numbers from 1 to 10 by first generating a vector \texttt{a} from 1 to 5, and a vector \texttt{b} from 6 to 10 then combine them into a single vector \texttt{c}:

<<>>=
a <- c(1, 2, 3, 4, 5)
b <- c(6, 7, 8, 9, 10)
c <- c(a, b)
c
@

You can also create string vectors containing only string values:

<<>>=
a <- c("this", "is", "a", "string", "vector")
a
@



A vector can only contain one type of scalar: either numeric or character. If you try to create a vector with numeric and character scalars, then R will convert all of the numeric scalars to characters:


<<>>=
movie <- "Pirates of the Carribean"
revenue <- 634954111
c(movie, revenue) # Result is a string vector
@


Once you've created a vector, you can easily determine its length by using the \texttt{length()} function:

\newfun{length()}\index{length()}

<<>>=
length(c(1, 2, 3))
@


\section{Generating numeric vectors}

While the c() operator is the most straightforward way to create a vector, it's also one of the most tedious. Let's say you wanted to create a vector of all integers from 1 to 100. You definitely don't want to have to type all the numbers into a c() operator. Instead, R has many simple built-in functions for generating numeric vectors. Let's start with three of them:

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{a:b}\index{a:b}

\hline

\begin{description}

  \item[\tt{a}] \hfill \\
      The start of the sequence
  \item[\tt{b}] \hfill \\
      The end of the sequence
\end{description}

}
}
\vspace{5mm} %5mm vertical space

The \texttt{a:b} function creates a vector of numbers from the starting point a to the ending point b in steps of 1:

\begin{footnotesize}
<<>>=
1 : 10 # Integers from 1 to 10
10 : 1 # Integers from 10 to 1
20.1:30.1 # From 20.1 to 30.1
@
\end{footnotesize}



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{seq(from, to, by)}\index{seq()}

\hline

\begin{description}

  \item[\tt{from}] \hfill \\
      The start of the sequence
  \item[\tt{to}] \hfill \\
      The end of the sequence
  \item[\tt{by}] \hfill \\
      The step-size of the sequence \\
  \item[\tt{length.out}] \hfill \\
      The desired length of the final sequence (only use if you don't specify \texttt{by})
\end{description}

}
}
\vspace{5mm} %5mm vertical space

\marginnote{\textbf{seq(from, to, by)} - Creates a sequence between two numbers in steps that you specify. \\ \texttt{from}: The starting value \\ \texttt{to}: The ending value \\ \texttt{by}: The step size between \texttt{begin} and \texttt{end}}

The \texttt{seq()} function allows you to create a sequence from a starting number to an ending number, in steps you specify. The function has three arguments, which are inputs to the function which changes how it works.

\begin{footnotesize}
<<>>=
seq(from = 1, to = 10, by = 1)
seq(from = 0, to = 100, by = 10)
@
\end{footnotesize}


The \texttt{rep()} function rep allows you to repeat a number (or vector) a specified number of times. There are three arguments to the rep function:

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{rep(x, times, each)}\index{rep()}

\hline

\begin{description}

  \item[\tt{x}] \hfill \\
      A scaler or vector of values to repeat
  \item[\tt{times}] \hfill \\
      The number of times to repeat the sequence
  \item[\tt{each}] \hfill \\
      The number of times to repeat each value within the sequence \\
\end{description}

}
}
\vspace{5mm} %5mm vertical space

\marginnote{\textbf{rep(x, times, each)} - Repeats the numbers in x in a manner you specify \\ \texttt{times}: The number of times the vector should be repeated \\ \texttt{each}: The number of times you want to repeat each element in the vector.}


\begin{footnotesize}
<<>>=
rep(1:5, times = 2) # Repeat integers 1 to 5 two times
rep(1:5, each = 2) # Repeat each integer from 1 to 5 two times
rep(1:5, each = 2, times = 2) # Do both!
@
\end{footnotesize}

\subsection{Arithmetic operations on scalars and vectors}

You can do basic arithmetic operations like +, -, * and / on scalars and vectors. If you do an operation on a vector with a scalar, R will apply the scalar to each element in the vector:

\begin{footnotesize}
<<>>=
a <- 1:5
a * 10
a - 1
a ^ 2
@
\end{footnotesize}

If you do an operation on two vectors, R will try to apply the operation between the vectors by each item:

\begin{footnotesize}
<<>>=
1:10 + 21:30

(1:5) * (1:5)

seq(10, 100, 10) + 1:10
@
\end{footnotesize}

\subsection{Additional Tips}


\begin{enumerate}
  \item To get more tips on how good coding techniques, check out the R style guide at http://adv-r.had.co.nz/Style.html
  \item For great blog articles on R, check out http://www.r-bloggers.com/
  \item If you need to enter a lot of numeric data into R by hand you might want to use the \texttt{scan()} function. This function allows you to easily enter data using 10-key typing on a number pad. To do this, run the code \texttt{scan()} and then enter the data number by number. When you are finished, R will then print the appropriate code to store the data into a vector.
  \item You can run several lines of code in one line by separating the code with the ; key. For example, the following two chunks of code are the same:
  
<<>>=
a <- 1
b <- 14
c <- 67
@

<<>>=
a <- 1 ; b <- 14 ; c <- 67
@

  
  However, I recommend you use the ; key sparingly. If you get in the habit of trying to cram several lines of code in one line, your code will get cluttered and difficult to understand.

\end{enumerate}


%----------------------------------------------------------------------------------------
%	CHAPTER 3
%----------------------------------------------------------------------------------------

\chapter{3: Sampling data and Descriptive Statistics}
\label{ch:3}

\textit{Chapter Goals}

\begin{enumerate}
  \item Learn functions for generating data from probability distributions: rnorm(), runif(), sample()
  \item Learn functions for basic descriptive statistics: mean(), median(), sd(), var(), min(), max()
\end{enumerate}


\section{Sampling data from probability distributions}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
# Create blank plot
plot(1, xlim = c(0, 100), ylim = c(0, 100),
     xlab = "Pirate Quality", ylab = "", type = "n",
     main = "Two different Pirate colleges", yaxt = "n"
     )

# Set colors
require("RColorBrewer")
col.vec <- brewer.pal(10, name = "Set3")[4:6]

# Draw Samples
samples.1 <- runif(n = 5, 40, 60)
samples.2 <- runif(n = 5, 10, 90)

text(50, 90, "Pirate Training Unlimited", font = 3)

for(i in 1:length(samples.1)) {
  
  points(samples.1[i], 75, pch = 21, bg = col.vec[1], cex = 3)
  text(samples.1[i], 75, round(samples.1[i], 0))
  
}

segments(40, 65, 60, 65, col = col.vec[1], lty = 1, lwd = 2)

text(50, 40, "Unlimited Pirate Training", font = 3)

for(i in 1:length(samples.2)) {
  
  points(samples.2[i], 25, pch = 21, bg = col.vec[2], cex = 3)
  text(samples.2[i], 25, round(samples.2[i], 0))
  
}

segments(10, 15, 90, 15, col = col.vec[2], lty = 1, lwd = 2)
@
\end{tiny}
\caption{Sampling 5 potential pirates from two different pirate colleges. Pirate Training Unlimited (PTU) consistently produces average pirates (with scores between 40 and 60), while Unlimited Pirate Training (UPT), produces a wide range of pirates from 0 to 100.}
\label{fig:piratecollege}
\end{marginfigure}
By now you know how to generate sequences of numbers with the functions :, \texttt{seq()}, and \texttt{rep()}. However, these functions don't generate very interesting data. Instead, we can use R to generate randomly sampled data from specified \textit{probability distributions}. A probability distribution is simply an equation that indicates how likely certain numerical values are to be drawn. When you draw a \textit{sample} of size N from a distribution, you are selecting N numerical values drawn according to that distribution's likelihood function.

For example, imagine you need to hire a new group of pirates for your crew. You have the option of hiring people form one of two different pirate training colleges that produce pirates of varying quality. One college ``Pirate Training Unlimited" might tend to pirates that are generally ok - never great but never terrible. While another college ``Unlimited Pirate Training" might produce pirates with a wide variety of quality, from very low to very high. In Figure~\ref{fig:piratecollege} I plotted 5 example pirates from each college, where each pirate is shown as a ball with a number written on it. As you can see, pirates from PTU all tend to be clustered between 40 and 60 (not terrible but not great), whlie pirates from UPT are all over the map, from 0 to 100. We can use probability distributions (in this case, the uniform distribution) to 


%\marginnote{Mathematically, a probability distribution must satisfy two criteria: 1) All likelihoods must be positive, 2) The sum (or integral) of all likelihoods must equal 1.} 

In the next section we'll go over some of the most commonly used sampling distributions: the Normal and Uniform distributions.

\pagebreak
\subsection{The Normal (Gaussian) distribution}

\begin{marginfigure}
\begin{tiny}
<<fig.height = 5, fig.width = 5>>=
require("RColorBrewer")

# Create blank plot
plot(1, xlim = c(-5, 5), ylim = c(0, 1),
     xlab = "x", ylab = "dnorm(x)", type = "n",
     main = "Three Normal Distributions"
     )

# Set up design matrix for loop
design.matrix <- data.frame("mean" = c(0, -2, 1),
                            "sd" = c(1, .5, 2)
                            )
# Set colors
col.vec <- brewer.pal(10, name = "Set3")[4:6]

# Start loop over distributions
for (i in 1:nrow(design.matrix)) {

mean.i <- design.matrix$mean[i]
sd.i <- design.matrix$sd[i]

fun <- function(x) {
  dnorm(x, mean = mean.i, sd = sd.i)}

curve(expr = fun, 
      from = -5,to = 5, 
      xlab = "x", lwd = 3,
      add = T, col = col.vec[i])

samples <- rnorm(n = 10, mean = mean.i, sd = sd.i)

segments(x0 = samples, y0 = rep(0, 10),
         x1 = samples, y1 = fun(samples),
         col = col.vec[i], lwd = 1, lty = 2
         )
}

legend.fun <- function(i) {
  paste("mean = ", design.matrix$mean[i],
        ", sd = ", design.matrix$sd[i], sep = "")}

legend("topright",
       legend = c(legend.fun(1),
                  legend.fun(2),
                  legend.fun(3)
                  ),
       lwd = rep(3, 3),
       col = col.vec[1:3]
       )
@
\caption{Three different normal distributions with different means and standard deviations.}
\label{fig:normaldist}
\end{tiny}
\end{marginfigure}
Let's start with the most famous distribution in statistics: the Normal (or if you want to sound pretentious, the Gaussian) distribution. The Normal distribution is bell-shaped, and has two parameters: a mean and a standard deviation. See the margin figure~\ref{fig:normaldist} for plots of three different Normal distributions with different means and standard deviations.


To generate samples from a normal distribution in R, we use the function \texttt{rnorm()} this function has three arguments:




\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{rnorm()}\index{rnorm()}

\hline

\begin{description}

\item[\tt{n}] \hfill \\
    The number of observations
\item[\tt{mean}] \hfill \\
    The mean of the Normal distribution from which samples are drawn (not the sample mean!!)
\item[\tt{sd}] \hfill \\
  The standard deviation of the Normal distribution from which samples are drawn
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space


For example, let's draw 5 samples (\texttt{n = 5}) from a normal distribution with mean 0 (\texttt{mean = 0}) and standard deviation 1 (\texttt{sd = 1})

<<>>=
rnorm(n = 5, mean = 0, sd = 1)
@

This code returns a vector of 5 values, where each value is a new random sample drawn from a Normal distribution with mean = 0 and standard deviation = 1.

Because the sampling is done randomly, you'll get different values each time you run the \texttt{rnorm()} (or any other random sampling) function. To see this, let's create two different sets of samples from a normal distribution with mean 10 and standard deviation 5 and see how they compare:

<<>>=
a <- rnorm(5, mean = 10, sd = 5)
b <- rnorm(5, mean = 10, sd = 5)
a # print a
b # print b
@


As you can see, even though I used the exact same code to generate the vectors \texttt{a} and \texttt{b}, the numbers in each sample are different. That's because the samples are each drawn randomly and independently from the normal distribution. To visualize the sampling process, run the code in the margin Figure~\ref{fig:normaldist} on your machine several times. You should see the sampling lines dance around the distribution. 

\subsection{The Uniform distribution}

Next, let's move on to the \textit{uniform} distribution. The uniform distribution gives equal probability to all values between the minimum and maximum values.

\begin{marginfigure}
\begin{tiny}
<<fig.height = 5, fig.width = 5>>=
# uniform distribution
curve(dunif, 
      from = 0, to = 1,
      xlim = c(-.5, 1.5),
      xlab = "x", 
      lwd = 2, 
      main = "Uniform\nmin = 0, max = 1")
@
\caption{The Uniform distribution - known colloquially as the Anthony Davis distribution.}
\label{fig:unif_dist}
\end{tiny}
\end{marginfigure}


To generate samples from a uniform distribution, we use the function \texttt{runif()}, the function has 3 arguments:

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{runif()}\index{runif()}

\hline

\begin{description}

\item[\tt{n}] \hfill \\
    The number of observations (i.e.; samples)
\item[\tt{min}] \hfill \\
    The lower bound of the Uniform distribution from which samples are drawn
\item[\tt{max}] \hfill \\
    The upper bound of the Uniform distribution from which samples are drawn
\end{description}

}
}
\vspace{5mm} %5mm vertical space




Let's draw 5 samples from two uniform distributions, one with bounds at 0 and 1, and one with bounds at -100 and 100:

\begin{footnotesize}
<<>>=
runif(5, min = 0, max = 1) # 5 samples from U[0, 1]
runif(5, min = -100, max = 100) # 5 samples from U[-100, 100]
@
\end{footnotesize}

\subsection{Sampling from a set of values: sample()}

The next function we'll use is \textbf{sample()}. The sample function works a bit differently from \texttt{runif()} and \texttt{rnorm()} because it allows to you to define which values you want to sample and the probability associated with each value. For example, if you want to simulate the flip of a fair coin, you can tell the sample function to draw the value "Heads" with probability .50, and the value "Tails" with probability .50.


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{sample()}\index{sample()}

\hline

\begin{description}

\item[\tt{x}] \hfill \\
    A vector of outcomes you want to sample from. For example, to simulate coin flips, you'd enter \texttt{x = c("Heads", "Tails")}
\item[\tt{size}] \hfill \\
    The number of samples you want to draw.
\item[\tt{replace}] \hfill \\
    Should sampling be done with replacement? If T, then each individual sample will be replaced in the data vector. If F, then the same outcome will never be drawn more than once. Think about replacement like drawing different balls from a bag. Sampling with replacement (\texttt{replace = T}) means that each time you draw a ball, you return the ball back into the bag before drawing another ball. Sampling without replacement (\texttt{replace = F}) means that after you draw a ball, you remove that ball from the bag before drawing again.
\item[\tt{prob}] \hfill \\
    A vector of probabilities of the same length as \texttt{x} indicating how likely each outcome in "x" is. For example, to sample equally from two outcomes, you'd enter \texttt{prob = c(.5, .5)}. The first value corresponds to the first value of x and the second corresponds to the second value (etc.). The vector of probabilities you give as an argument should add up to one. However, if they don't, R will just rescale them so that they will sum to 1.
    
\end{description}

}
}
\vspace{5mm} %5mm vertical space


As a simple example, let's simulate 10 flips of a fair coin, were the probably of getting either a Head or Tail is .50:

\begin{footnotesize}
<<>>=
sample(x = c("Heads", "Tails"), # The values you want to sample from
       size = 10,  # The number of samples
       prob = c(.5, .5), # The probability of each value
       replace = T # Sampling with replacement
       )
@
\end{footnotesize}

As you can see, our function returned a vector of 10 values corresponding to our sample size of 10. Keep in mind that, just like using \texttt{rnorm()} and \texttt{runif()}, the \texttt{sample()} function can give you different outcomes every time you run it.


\begin{marginfigure}
\begin{tiny}
<<fig.width = 3.5, fig.height = 3.5>>=
par(mar = c(3, 3, 3, 3))
plot(1, xlim = c(0, 1), ylim = c(0, 1), 
     xlab = "", ylab = "", xaxt = "n", 
     yaxt = "n", type = "n", 
     main = "Chest of 20 Gold, 30 Silver,\nand 50 Bronze Coins")

points(runif(100, .1, .9), 
       runif(100, .1, .9),
       pch = 21, cex = 3,
       bg = c(rep("gold", 20), 
              rep("gray94", 30), 
              rep("chocolate", 50))
       )
@
\end{tiny}
\end{marginfigure}

\subsection{Drawing coins from a treasure chest}

Now, let's sample drawing coins from a treasure chest Let's say the chest has 100 coins: 20 gold, 30 silver, and 50 bronze. Let's draw 10 random coins from this chest. Because we remove coins when we draw them, we'll set \texttt{replace = F}.

<<>>=
# Create chest with the 100 coins

chest <- c(rep("gold", 20), 
         rep("silver", 30), 
         rep("bronze", 50)
         )

# Draw 10 coins from the chest without replacement

sample(x = chest,
       size = 10,
       prob = rep(1 / 100, times = 100),
       replace = F
       )
@

The output of the \texttt{sample()} function above is a vector of 10 strings indicating the type of coin we drew on each sample. The order of these strings matter: the first one is the first coin we drew, and the last one is the 10th coin we drew. And like any random sampling function, this code will likely give you different results everytime you run it! See how long it takes you to get 10 gold coins...

\subsection{Simulating Pinder Outcomes}

\begin{marginfigure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/pinder.pdf}
\caption{A typical Pinder profile.}
\label{fig:pinder}
\end{marginfigure}


Let's simulate some Pinder outcomes. For those who don't know, Pinder is an app that allows Pirates to view profiles of potential dates. For each potential date, you can see their picture and either "like" them by swiping right, or "dislike" them by swiping left. If a pirate that you "liked" also "likes" you, then you've had a successful match and will be able to start chatting. let's say you "swipe right" on 20 Pinder profiles and the probability you get a match is 20\%. We can simulate this using the sample function

\begin{footnotesize}
<<>>=
sample(x = c("Match!!!", "No Match"), 
       size = 20,
       replace = T, # Replace each sample back to the set
       prob = c(.2, .8)  # Probability of Match! is .2, and No Match :( is .8)
       )
@
\end{footnotesize}

The output of this function is a simulated response from 10 pirates that you liked. 

%In the example above I set \texttt{replace = T}. If I didn't do this, then on the third sample R would run out of objects to draw from. However, there are cases where we would not want sampling with replacement: for example, when deciding where to go clubbing in Berlin...

%' \subsection{Where should I go clubbing in Berlin...?}
%' 
%' 
%' \begin{marginfigure}
%' \begin{tiny}
%' <<fig.width = 4, fig.height = 4>>=
%' par(mar = c(4, 4, 4, 4))
%'     
%' plot(1, xlim = c(0, 1), ylim = c(0, 1), 
%'      xlab = "", ylab = "", xaxt = "n", 
%'      yaxt = "n", type = "n", main = "Bag of clubs")
%' 
%' x.vals <- runif(5, .1, .9)
%' y.vals <- runif(5, .1, .7)
%' clubs <- c("Berghain", "Club der\nVisionare", 
%'              "Goldengate", "Watergate", "Keller")
%' for (i in 1:5) {
%' 
%' points(x.vals[i], 
%'        y.vals[i],
%'        pch = 21, cex = 13, bg = "white", lwd = 2
%'        )
%' 
%' 
%' text(x.vals[i], y.vals[i], 
%'      labels = clubs[i], cex = .8)
%'   }
%' @
%' \end{tiny}
%' \end{marginfigure}
%' 
%' Let's say you planning a weekend of clubbing in Berlin and need to decide on just 2 out of 5 clubs to visit. Since we don't want to visit the same club twice, we'll set \texttt{replace = F}. Additionally, because we want each of the clubs to be equally likely to be selected, we'll set the \texttt{prob} argument as a vector of five 1/5 values.
%' 
%' \begin{footnotesize}
%' <<>>=
%' clubs <- sample(x = c("Berghain", "Club der Visionare", 
%'              "Goldengate", "Watergate", "Keller"),
%'        size = 2,
%'        replace = F,
%'        prob = c(1/5, 1/5, 1/5, 1/5, 1/5) # Set the probability of each to 1/5
%'        )
%' clubs
%' @
%' \end{footnotesize}
%' 
%' Looks like R has selected \Sexpr{clubs[1]} and \Sexpr{clubs[2]}. Let's see if we even make it to \Sexpr{clubs[2]}...

\section{Descriptive statistics}

Ok, now that we can generate some data, let's learn the basic descriptive statistics functions. We'll focus on the most common ones for numerical analyses.


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{Common Descriptive Statistics}

\hline

\begin{description}

\item[\tt{mean(x)}] \hfill \\
    The arithmetic mean of a vector x
\item[\tt{median(x)}] \hfill \\
    The median of a vector x. 50\% of the data should be less than \texttt{median(x)} and 50\% should be greater than \texttt{median(x)}.
\item[\tt{sd(x), var(x)}] \hfill \\
    The standard deviation and variance of a vector x.
\item[\tt{min(x), max(x)}] \hfill \\
    The minimum and maximum values of a vector x
\item[\tt{quantile(x, p)}] \hfill \\
    The pth sample quantile of a vector x. For example, \texttt{quantile(x, .2)} will tell you the value at which 20\% of cases are less than x. The function \texttt{quantile(x, .5)} is identical to \texttt{median(x)}
\item[\tt{summary(x)}] \hfill \\ 
  Shows you several descriptive statistics of a vector x, including \texttt{min(x)}, \texttt{max(x)}, \texttt{median(x)}, \texttt{mean(x)}
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space


Each of these functions takes a vector as an argument, and returns a scalar as a result. Let's calculate some descriptive statistics from some pirate related data. I'll create a vector called \texttt{data} that contains the number of tattoos from 10 random pirates

<<>>=
tattoos <- c(4, 50, 2, 39, 4, 20, 4, 8, 10, 100)
@

To calculate the mean of the data, we simply write:

<<>>=
mean(tattoos)
@

The other descriptive statistics functions are just as easy: Let's test the \texttt{median()}, \texttt{sd()}, \textt{min()}, and \texttt{max()} functions:

\begin{footnotesize}
<<>>=
median(tattoos)
sd(tattoos)
min(tattoos)
max(tattoos)
@
\end{footnotesize}

One important point about the descriptive statistics functions is that most (if not all) of them as a default will freak out if there is a missing (NA) value in the data. For example, the following code will return NA as a result because there is an NA value in the data vector:

\marginnote{Include the argument \textt{na.rm = T} to ignore missing (NA) values when calculating a descriptive statistic.}

<<>>=
mean(c(1, 5, NA, 2))
@

To tell a descriptive statistic function to ignore missing (NA) values, include the argument \texttt{na.rm = T} in the function:

<<>>=
mean(c(1, 5, NA, 2), na.rm = T)
@

Now, the function will ignore NA and calculate the mean of the non-missing values. While this may seem trivial now (why did we include an NA value in the vector if we wanted to ignore it?!), it will be become very important when we apply the function to large existing datasets that may contain missing values.

If you want to get many summary statistics from a vector, you can use the \textbf{summary()} function which gives you several key statistics:

\begin{footnotesize}
<<>>=
summary(tattoos)
@
\end{footnotesize}





\subsection{Other helpful vector functions}

Here are some other functions that you will find useful when managing numeric vectors:


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{Other helpful numeric functions}

\hline

\begin{description}

\item[\tt{round(x, digits)}] \hfill \\
    Round values in a vector (or scaler) x to a certain number of digits.
\item[\tt{ceiling(x), floor(x)}] \hfill \\
   Round a number to the next largest integer with \texttt{ceiling(x)} or down to the next lowest integer with \texttt{floor(x)}.
\item[\tt{x \%\% y}] \hfill \\
    Modular arithmetic (i.e.; x mod y). You can interpret \texttt{x \%\% y} as ``What is the remainder after dividing x by y?" For example, \texttt{10 \%\% 3} equals 1 because 3 times 3 is 9 (which leaves a remainder of 1).
\end{description}

}
}
\vspace{5mm} %5mm vertical space


\section{A worked example: A quick test of the law of large numbers}

According to the law of large numbers, the larger our sample size, the closer our sample mean should be to the population mean. In other words, the more data (samples) you have, the more accurate your estimate should be. Let's test this by drawing either a small (N = 10) or a large (N = 1,000,000) number of observations from a Normal distribution with mean = 100 and sd = 20:

\marginnote{Tip: You can easily write large powers of 10 by using the notation \texttt{1eN}, where N is the power of 10. For example: \texttt{1e6} is the same as 1,000,000}

\begin{footnotesize}
<<>>=
small <- rnorm(10, mean = 100, sd = 20) # 10 observations
large <- rnorm(1e6, mean = 100, sd = 20) # One million observations
@
\end{footnotesize}

If our test worked, then the difference for the small sample should be larger than the large sample. Let's test this by calculating the mean of each sample and see how close they are to the true population mean of 100:

\begin{footnotesize}
<<>>=
mean(small) # What is the mean of the small sample?
mean(large) # What is the mean of the large sample?

mean(small) - 100 # How far is the mean of Small from 100?
mean(large) - 100 # How far is the mean of Large from 100?
@
\end{footnotesize}

Looks like the law of large numbers holds up!

\subsection{Additional Tips}


%----------------------------------------------------------------------------------------
%	CHAPTER 4
%----------------------------------------------------------------------------------------

\chapter{4: Indexing and comparing vectors}
\label{ch:4}


Chapter Goals:

\begin{enumerate}
  \item Use brackets [] and logical vectors to index vectors
  \item Combine indexing with descriptive statistics
  \item Learn indexing functions which(), sort()
  \item Vector discrete summary functions table() and unique()
  \item Set functions: intersect(), union(), setdiff(), %in%
\end{enumerate}


\section{Indexing vectors with brackets}

\marginnote{\textbf{Indexing with brackets [ ]} \\ To get the ith value of a vector called \texttt{vec}, use the bracket notation \textt{vec[i]}}

When we have a vector, we will frequently want to access specific values of a vector. These might be values in a specific location in the vector (i.e.; the fifth element) or based on some criteria (i.e.; all values greater than 0). We can accomplish this using indexing.

\newfun{vector[index]}\index{[]}

There are two main ways that you can use indexing to access subsets of data in a vector: numerical and logical indexing.

\subsection{Numerical Indexing}

With numerical indexing, you enter the integers corresponding to the values in the vector you want to access in the form \textt{data[num.index]}, where \texttt{data} is the data vector, and \texttt{num.index} is a vector of index values. For example, to get the first value in a vector, you'd write \texttt{data[1]}. To get the first, second, and third value, you can either type \texttt{data[c(1, 2, 3)} or \texttt{data[1:3]}.

Let's do a few more examples. We'll use the \texttt{tattoos} vector again and use indexing to extract specific values:
  
\begin{footnotesize}
<<>>=
tattoos <- c(0, 50, 2, 39, 9, 20, 17, 8, 10, 100)
tattoos[1] # First element of tattoos
tattoos[1:5] # 1-5 elements of tattoos
@

If you have defined an object that is a vector of integers, you can then index a variable using that vector. For example, let's define an object called \texttt{index} and use this object to index our data vector:
  
\begin{footnotesize}
<<>>=
get.these.values <- 6:10 
tattoos[get.these.values] # Indexing with a named object
@
\end{footnotesize}

You can also get random values from a vector by indexing a vector with the \texttt{sample()} function. Let's get 3 random values from the \texttt{tattoo} vector in 2 steps. First, we'll create 3 random indexing values using \texttt{sample()}. Secind, we'll index the \texttt{tattoo} object with the indexing values we generated in the first step.

\begin{footnotesize}
<<>>=
rand.values <- sample(x = 1:length(tattoos),  # Step 1: Determine indexing values
                      size = 3, 
                      replace = F)

tattoos[rand.values] # Step 2: Index tattoo with rand.values
@
\end{footnotesize}

The result of our indexing is 3 randomly selected values from the \texttt{tattoos} vector. Of course, we also could have done the same thing in one step by just entering \texttt{tattoos} as an argument to \texttt{sample()} like this:

\begin{footnotesize}
<<>>=
sample(x = tattoos, size = 3, replace = F)
@
\end{footnotesize}

As you gain more experience with R, you'll realise that there are many ways to program the same result. The choice of which code you use comes down to a delicate balance of readability (How easily can your future self, and other people, understand what the code is doing?), simplicity (How many lines of code are necessary?), and processing speed (How quickly will R complete the task?).

\section{Creating logical vectors}


\begin{marginfigure}
\begin{tiny}
<<>>=
par(mar = rep(.1, 4))
plot(1, xlim = c(0, 1.1), ylim = c(0, 9), 
     xlab = "", ylab = "", xaxt = "n", yaxt = "n", 
     type = "n")


text(rep(0, 8), 8:1, 
     labels = c("==", "!=", "<", "<=", 
                ">", ">=", "|", "!"),
     adj = 0, cex = 3)

text(rep(.2, 8), 8:1, 
     labels = c("equal", "not equal", "less than",
                "less than or equal","greater than", 
                "greater than or equal", "or", "not"),
        adj = 0, cex = 3)


@
\caption{Comparison operators in R}
\label{fig:comparison}
\end{tiny}
\end{marginfigure}



\begin{marginfigure}
\begin{tiny}
<<>>=
# Create blank plot with no margins
par(mar = rep(0, 4))
plot(1, xlim = c(0, 1), ylim = c(0, 13), 
     bty = "n", xlab = "", ylab = "", main = "",
     type = "n", xaxt = "n", yaxt = "n")

# Add Main title
text(.5, 12.5, "log.vec <- data.vec > 0", cex = 2)

# Data vector
text(.3, 11.1, "data.vec", font = 2, cex = 1.6)
data.vec <- c(2, 7, -1, 5, -9, -2, 3, 0, 2, -2)
text(rep(.3, 10), 10:1, data.vec, cex = 1.6)
rect(.25, .5, .35, 10.5)
segments(rep(.25, 9), seq(1.5, 9.5, 1), 
         rep(.35, 9), seq(1.5, 9.5, 1), lty = 2)


# Comparisons
text(.5, 11.1, "test", cex = 1.6, col = gray(.5))
text(rep(.5, 10), 1:10, "> 0", col = gray(.5))

# Logical vector
text(.7, 11.1, "log.vec", font = 2, cex = 1.6)
index.text <- rep("FALSE", 10)
index.text[data.vec > 0] <- "TRUE"
col.vec <- rep("red", 10)
col.vec[data.vec > 0] <- "blue"
text(rep(.7, 10), 10:1, 
     index.text, 
     col = col.vec, cex = 1.6
     )
rect(.6, .7, .8, 10.5)
segments(rep(.6, 9), seq(1.5, 9.5, 1), 
         rep(.8, 9), seq(1.5, 9.5, 1), lty = 2)
@
\end{tiny}
\label{fig:logvec1}
\caption{Creating a logical vector from a data vector with a comparison operator. In this case, the logical comparison is "> 0" and each element of the data vector is compared to 0.}
\end{marginfigure}

Another way to index data vectors is with logical vectors. A logical vector is a vector that only contains TRUE and FALSE values. If you index a vector with a logical vector (of the same length), you will only receive the values for which the index is TRUE.

You can create a logical vector by using the comparison operators in Figure~\ref{fig:comparison}.

Let's start by creating single scalar logical values so you can see how they work. If you apply a comparison operator to a scalar, R will return a single logical value of TRUE or FALSE. Let's see if 3 truly equals 3 and if 3 is really not greater than 5.

\begin{footnotesize}
<<>>=
3 == 3
3 > 5
@
\end{footnotesize}

The negation operator \texttt{!} meaning NOT. To use it, place the statement you are testing in parentheses, and place the \texttt{!} operator before it:

\begin{footnotesize}
<<>>=
pirate <- "david"
pirate == "jack"
!(pirate == "jack")
!(2 == 4)
@
\end{footnotesize}




In addition to using single comparison operators, you can combine multiple logical comparisons using the OR \texttt{|} and AND \texttt{\&} commands. The OR command will return TRUE if any of the values in the set is TRUE, while the AND command will only return TRUE if all of the values in the set are TRUE.

\begin{footnotesize}
<<>>=
(1 < 3) # Is 1 less than 3?
(4 < 2) # Is 4 less than 2?
(1 < 3) & (4 < 2) # Is 1 less than 3 and is 4 less than 2?
(1 < 3) | (4 < 2) # Is 1 less than 3 OR is 4 less than 2?
@
\end{footnotesize}

If you apply a comparison operator between a scalar and a vector, R will return a logical vector of length equal to the length of the vector. For example, let's compare a vector of integers from 1 to 10 to a scalar value of three and look at the output:

\begin{footnotesize}
<<>>=
1:10 == 3 # Are the values equal to 3?
@
\end{footnotesize}

Let's look at the outputs above: for each value of the object \texttt{vec}, R performs the comparison \texttt{== 3}. Because only the third element of the vector is equal to 3, R returns the value \texttt{FALSE} for all values except the third one.

You can also compare two vectors of equal length and obtain a single logical vector as a result. For example, let's say we have two data vectors (data.1 and data.2) and we want a logical vector telling us which values of the two data vectors are equal. We can do this by just executing \texttt{data.1 == data.2}

\begin{footnotesize}
<<>>=
data.1 <- c(1, 4, 2, 3, 3)
data.2 <- c(1, 2, 4, 3, 3)
data.1 == data.2
@
\end{footnotesize}

\newfun{x \%in\% y}\index{\%in\%}

One very important function for creating logical indices is \texttt{\%in\%}. This function looks a bit different from other functions because it doesn't follow the typical format of function(x, y). Instead, you place the function \%in\% between its arguments. When you execute x \%in\% y, R will evaluate, for each element in the vector x, if it is in the vector y. For example. Let's create several vectors x and y and use the \%in\% function to text whether or not the elements of x are in y:

\begin{footnotesize}
<<>>=
1 %in% c(1, 2, 3, 4, 5)
@
\end{footnotesize}

In this example, R returns a single value of TRUE because it found the value of 1 in the second vector. However, you can also apply the \%in\% function to a vector x that is longer than 1. When you do this, the \%in\% function will return a vector equal to the length of x. Now, let's try an example where we test whether each of several values are in a second set:

\begin{footnotesize}
<<>>=
c(1, 2, 3, 77, 88, 99) %in% c(1, 2, 3, 4, 5)
@
\end{footnotesize}

In this example R checked, for each of the values in the first vector if it was in the second vector (\texttt{c(1, 2, 3, 4, 5)}). Because only the first three values (1, 2 and 3) were in the second vector, R returns a vector with 3 TRUE values and 3 FALSE values.

The \%in\% function is very handy for seeing which values in a vector are valid according to a criteria you specify. For example, imagine you conducted a survey where you asked 10 different pirates how many siblings they had and received the following responses:

<<>>=
siblings <- c(3, 2, 0, -5, 0, -20, 2, 3, 1, -200)
@

Of course, the only valid answers to this question should be 0, 1, 2, ... up to a maximum of say 20; but some of these values appear to be invalid (that is, negative). Let's use the \%in\% function to see which values in the survey are valid. We'll create a vector called \texttt{valid.responses} that represents all possible valid answers to the question (we'll limit the number of siblings to 20). We'll then use \%in\% to create a logical vector indicating which responses were valid. 

\begin{footnotesize}
<<>>=
siblings <- c(3, 2, 0, -5, 0, -20, 2, 3, 1, -200)
valid.responses <- seq(0, 20, 1)
siblings %in% valid.responses
@
\end{footnotesize}

Because the fourth, sixth, and tenth values were not valid (they were negative), the final logical vector gives us FALSE values at those index values, and TRUE values for all others.

\section{Indexing data with logical vectors}

\begin{marginfigure}
\begin{tiny}
<<>>=
# Create blank plot with no margins
par(mar = rep(0, 4))
plot(1, xlim = c(0, 1), ylim = c(0, 13), 
     bty = "n", xlab = "", ylab = "", main = "",
     type = "n", xaxt = "n", yaxt = "n")

# Add Main title
text(.5, 12.5, "output.vec <- data.vec[log.vec]", cex = 2)

# Data vector
text(.2, 11.1, "data.vec", font = 2, cex = 1.6)
data.vec <- c(2, 7, -1, 5, -9, -2, 3, 0, 2, -2)
text(rep(.2, 10), 10:1, data.vec, cex = 1.6)
rect(.15, .5, .25, 10.5)
segments(rep(.15, 9), seq(1.5, 9.5, 1), 
         rep(.25, 9), seq(1.5, 9.5, 1), lty = 2)
text(rep(.12, 10), 10:1, 1:10, cex = .8)

# Comparisons
text(rep(.32, 10), 1:10, "> 0", col = gray(.5))

# Logical vector
text(.5, 11.1, "log.vec", font = 2, cex = 1.6)
index.text <- rep("FALSE", 10)
index.text[data.vec > 0] <- "TRUE"
col.vec <- rep("red", 10)
col.vec[data.vec > 0] <- "blue"
text(rep(.5, 10), 10:1, 
     index.text, 
     col = col.vec, cex = 1.6
     )
rect(.4, .5, .6, 10.5)
segments(rep(.4, 9), seq(1.5, 9.5, 1), 
         rep(.6, 9), seq(1.5, 9.5, 1), lty = 2)

# Output vector
text(.8, 11.1, "output.vec", font = 2, cex = 1.6)
output.text <- data.vec[data.vec > 0]
text(rep(.8, 5), 7:3, output.text, cex = 1.6)
rect(.75, 2.5, .85, 7.5)
segments(rep(.75, 9), seq(3.5, 6.5, 1), 
         rep(.85, 9), seq(3.5, 6.5, 1), lty = 2)
text(rep(.88, 5), 7:3, which(data.vec > 0), cex = .8)

# Arrows connecting log.vec to output.vec
arrows(rep(.6, 5),
       11 - which(data.vec > 0),
       rep(.73, 5),
       7:3, lwd = .5, length = .15
       )
@
\end{tiny}
\label{fig:logvec2}
\caption{A visual representation of how indexing with logical vectors works in R. When you apply a logical vector (a vector containing only TRUE and FALSE values) to a data vector, R will return the the values in the data vector where the logical vector is TRUE.}
\end{marginfigure}

Once we have a logical vector, we can use that vector as an indexing vector. That is, you can use it to select values of a vector that satisfy some criteria you specify. To do this, you create a logical vector containing TRUE and FALSE values. If you then index a data vector (with the same length as the logical vector), R will return the values of the data vector for all TRUE values of the logical vector. See Figure~\ref{fig:logvec2} to see visually how this works.


For example, let's say that we have the following set of data

\begin{footnotesize}
<<>>=
tattoos <- c(4, 50, 2, 39, 4, 20, 4, 8, 10, 100)
@
\end{footnotesize}

Now, let's say that we want to access just the data points that are less than 10. We'll start by first creating a logical indexing vector that tells us whether each value is less than 1. Then, we'll index the original data vector using this logical vector:

\begin{footnotesize}
<<>>=
log.vec <- tattoos < 10 # Step 1: Create logical vector
tattoos[log.vec] # Step 2: Index the original data by the logical vector
@
\end{footnotesize}


Logical vectors aren't just good for indexing, you can also use them to figure out which values in a vector satisfy some criteria. To do this, use the function \textt{which()}

\newfun{which(log.vec)}%\marginnote{\texttt{\textbf{which(logical.vector)}}: Tells you the index value of all \texttt{TRUE} values in the logical vector. \\ For example, the command \texttt{which(c(T, T, F))} will return the vector \texttt{[1, 2]}, telling you that the first and second values are true.}

If you apply the function \texttt{which()} to a logical vector, R will tell you which values of the index are TRUE. For example, let's create a logical vector and then see which index values are TRUE

<<>>=
log.vec <- c(TRUE, TRUE, FALSE, TRUE, FALSE)
which(log.vec)
@

By using the \texttt{which()} function, we know that the first, second, and fourth elements of the logical vector are TRUE.

Let's take the example of comparing the treasure chest finding ability of 10 pirates. In each of two years - 2014 and 2015 - I measured how many chests 10 pirates found over the entire year. I recorded these values in two vectors, where the first value of each vector corresponds to the first pirate, and the last value corresponds to the last pirate:

\begin{footnotesize}
<<>>=
pirate.names <- c("Andrew", "Heidi", "Madisen", "Becki", "Jack Dyanamite")
chests.2014 <- c(0, 10, 1, 2, 5)
chests.2015 <- c(0, 6, 3, 0, 20)
@
\end{footnotesize}

Ok, so let's see which pirates improved their chest findind ability. I'll start by finding the index values where the number of chests found increased between the two years

\begin{footnotesize}
<<>>=
improve.log <- chests.2015 > chests.2014 # create logical vector
improve.log # print values
@
\end{footnotesize}

If I want to know the index values of the pirates who improved, I can use the \texttt{which()} function. The which function will tell me the index of each TRUE value in a logical vector:

\begin{footnotesize}
<<>>=
which(improve.log)
@
\end{footnotesize}

This vector tells us that the 3rd and 5th pirates found more chests in 2015 than 2014. Now I can use this index value to figure out the names of those pirates:

\begin{footnotesize}
<<>>=
pirate.names[which(improve.log)]
@
\end{footnotesize}


Because you can index vectors with logical vectors, I could get the same results by just indexing \texttt{pirate.names} with \texttt{improve.log}.

\begin{footnotesize}
<<>>=
pirate.names[improve.log]
@
\end{footnotesize}

For this example, the \texttt{which()} command was unnecessary, but it's important to understand the logic of both methods.

\section{Additional helpful vector functions}

Here are some other functions you might find useful when dealing with vectors:


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{Other Helpful Vector Functions}

\hline

\begin{description}

\item[\tt{length(x)}] \hfill \\
    The length of a vector
\item[\tt{sort(x)}] \hfill \\
    Sort a vector x. Add the argument \texttt{decreasing = T} to sort in decreasing order.
\item[\tt{rev(x)}] \hfill \\
    Reverse the order of a vector x
\item[\tt{unique(x)}] \hfill \\
    Determine all unique values in a vector x
\item[\tt{table(x)}] \hfill \\
  Determine the number of counts for all unique values in a vector x
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space

Once you have a vector of data, you may want to sort it in order to see, for example, the largest and smallest values. You can do this using the \texttt{sort()} function. Let's look back on my summer joke data and sort the results:

\begin{footnotesize}
<<>>=
tattoos <- c(4, 50, 2, 39, 4, 20, 4, 8, 10, 100)
sort(tattoos, decreasing = T) # Sort decreasing
sort(tattoos, decreasing = F) # Sort increasing
@
\end{footnotesize}

You'll notice that the sort function has an argument \texttt{decreasing} which you can set to TRUE or FALSE.

The function \texttt{unique(x)} will tell you all the unique values in the vector, but won't tell you anything about how often each value occurs.

\marginnote{\textbf{unique(x)}: Gives you all unique values in a vector, ignoring the number of times each value occurs.}

\begin{footnotesize}
<<>>=
unique(c(1, 1, 2, 2, 2, 4, 500))
unique(c("a", "A", "A", "A", "b", "b", "b", "c"))
@
\end{footnotesize}

The function \texttt{table()} does the same thing as \texttt{unique()}, but goes a step further in telling you how often each of the unique values occurs:

\marginnote{\textbf{table(x)}: Gives you all unique values in a vector and tells you how often each value occurs.}

\begin{footnotesize}
<<>>=
table(c(1, 1, 1, 2, 2, 5, 5, 700, 700, 1000))
table(c("a", "A", "A", "A", "b", "b", "b", "c"))
@
\end{footnotesize}

\section{Set Functions}

R contains many functions that allow you to compare two sets (vectors) of data. See margin Figure~\ref{fig:setfunctions} for a visual depiction. Here are the most common ones:



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{Set Functions}

\hline

\begin{description}

\item[\tt{union(x, y)}] \hfill \\
Tells you all unique values included in \textit{either} the vector x or y.
\item[\tt{intersect(x, y)}] \hfill \\
   Tells you all values common in \textit{both} the vectors x and y.
\item[\tt{setdiff(x)}] \hfill \\
    Tells you which values are in the vector x but \textit{not} in the vector y. Keep in mind that \texttt{setdiff(x, y)} is \textit{not} the same as \texttt{setdiff{y, x}}!
\item[\tt{setequal(x)}] \hfill \\
Returns TRUE of the two vectors x and y are identical (ignoring order) and FALSE if they are not identical.
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space



\begin{marginfigure}
\begin{tiny}
<<fig.width = 3.8, fig.height = 3.8>>=
require("plotrix")
require("RColorBrewer")

Transparent <- function(orig.col = "red", trans.val = 1, maxColorValue = 255) {
  
  if(length(orig.col) == 1) {orig.col <- col2rgb(orig.col)}
  if(!(length(orig.col) %in% c(1, 3))) {return(paste("length of original color must be 1 or 3!"))}

  final.col <- rgb(orig.col[1], orig.col[2], orig.col[3], alpha = trans.val * 255, maxColorValue = maxColorValue)
  
  return(final.col)
}


color.vec <- brewer.pal(12, "Set3")
par(mar = rep(0, 4))
plot(1, xlim = c(0, 1), ylim = c(0, 1), 
     bty = "n", xlab = "", ylab = "", main = "",
     type = "n", xaxt = "n", yaxt = "n")

draw.circle(x = .35, y = .5, radius = .35, col = Transparent(color.vec[4], .3), lwd = 2)
draw.circle(x = .65, y = .5, radius = .35, col = Transparent(color.vec[5], .3), lty = 2, lwd = 2)

text(.35, .1, "Set X", cex = 1.5)
text(.65, .1, "Set Y", cex = 1.5)

text(.5, .5, "intersect(x, y)")
text(.15, .5, "setdiff(x, y)")
text(.85, .5, "setdiff(y, x)")
text(.5, .9, "union(x, y)")
@
\end{tiny}
\label{fig:setfunctions}
\caption{Common set functions in R.}
\end{marginfigure}

\section{Using indexing to remove specific values of a vector}

Sometimes you might want to remove values of a vector before performing some analyses. This might be because some of the values are invalid or just not values that you want to include in your analyses. For example, let's say you asked 7 people how happy they were on a scale of 1 to 5 and received the following responses:

<<>>=
happy <- c(1, 4, 2, 999, 2, 3, -2)
@

As you can see, we have some invalid values (999 and -2) in this vector. We can use logical indexing to create a new vector called \texttt{happy.valid} that only contains values 1 through 5.

<<>>=
valid.log <- happy %in% c(1, 2, 3, 4, 5)
happy.valid <- happy[valid.log]
happy.valid
@

As you can see, the new vector \texttt{happy.valid} only contains values from the original vector that are integers from 1 to 5.

R has special functions for testing whether or not values in a dataset are either missing (or infinite). Here are some you can use:
  
  
  
  \vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{Logical testing functions}

\hline

\begin{description}

\item[\tt{is.integer(x)}] \hfill \\
Tests if values in a vector are integers
\item[\tt{is.na(x), is.null(x)}] \hfill \\
Tests if values in a vector are \texttt{NA} or \texttt{NULL}
\item[\tt{is.finite(x)}] \hfill \\
 Tests if a value is a finite numerical value. If a value is NA, NULL, Inf, or -Inf, \texttt{is.finite()} will return \texttt{FALSE}. 
\item[\tt{duplicated(x))}] \hfill \\
Returns \texttt{FALSE} at the first location of each unique value in x, and \texttt{TRUE} for all future locations of unique values. For example, \texttt{duplicated(c(1, 2, 1, 2, 3))} returns \texttt(FALSE, FALSE, TRUE, TRUE, FALSE). If you want to remove duplicated values from a vector, just run \texttt{x <- x[!duplicated(x)]}
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space
  

  
  You can use these functions to generate logical indices for indexing. For example, let's say you had a vector of data with several missing values. To create a new vector of data that does not contain the original NA values, we can index the original \texttt{data} vector with \texttt{is.finite(data)}:
  
<<>>=
data <- c(5, 2, NA, 3, NA, 10, NA)
data.finite <- data[is.finite(data)]
data.finite
@


\section{Taking the sum and mean of logical vectors to get counts and percentages}

Many (if not all) R functions that take numeric data as inputs will interpret TRUE values as 1 and FALSE values as 0. This allows us to easily answer questions like "How many values in a data vector are greater than 0?" or "What percentage of values are equal to 5?" by applying the \texttt{sum()} or \texttt{mean()} function to a logical vector.

Let's use this logic to see how many of the integers from 1 to 100 are greater than 0, 50, and 100:

<<>>=
sum(1:100 > 0) # How many values in 1:100 are greater than 0?
sum(1:100 > 50) # How many values in 1:100 are greater than 50?
sum(1:100 > 100) # How many values in 1:100 are greater than 50?
@

These results should make sense: every value from 1:100 is greater than 0, 50 are greater than 50, and non are greater than 100. Now, let's do the same thing but calculate percentages instead of counts using \texttt{mean()} instead of \texttt{sum()}:

<<>>=
mean(1:100 > 0) # How many values in 1:100 are greater than 0?
mean(1:100 > 50) # How many values in 1:100 are greater than 50?
mean(1:100 > 100) # How many values in 1:100 are greater than 50?
@

So far so good, now let's try this on our tattoo data:

<<>>=
tattoos <- c(4, 50, 2, 39, 4, 20, 4, 8, 10, 100)
@

Let's see see how many of these 10 pirates have more than 10 tattoos. We'll do this in two steps; First, we'll create a logical vector indicating which values are greater than 10. Second, we'll take the sum of this logical vector. This will tell us how many \texttt{TRUE} values there are in the logical vector:

<<>>=
log.vec <- tattoos > 10 # Step 1: Which values are > 10?
sum(log.vec) # Step 2: How many TRUE values are there?
@

Looks like \Sexpr{sum(log.vec)} pirates have more than 10 tattoos. Now, let's test what percent of pirates have 5 tattoos or less. We'll do this by first creating the logical vector, and then calculating the \texttt{mean()} of this vector. We can do this because the mean of a vector of 0s and 1s is identical to the percentage of 1s:

<<>>=
log.vec <- tattoos <= 5 # Step 1: Which values are <= 5?
mean(log.vec) # Step 2: What percent of values are TRUE?
@

Looks like \Sexpr{mean(log.vec) * 100}\% of pirates have 5 tattoos or less.


\marginnote{To see what percentage of values are TRUE in a logical vector, just take the mean of the vector. For example, the command \texttt{mean(c(-1, -2, 1, 1) > 0)} will return \texttt{0.50}, telling you that half of the values are positive.}


\subsection{Additional Tips}

\begin{itemize}

  \item If you have a vector of values and you want to know which values are duplicates of previous values, you can use the \texttt{duplicated} function. This function will go through the vector from beginning to end and tag the first unique instance of a value as TRUE and all repeated instances of a value as FALSE:
  
<<>>=
vec <- c("a", "b", "a", "a", "c")
duplicated(c("a", "b", "a", "a", "c"))
@

If you want to remove duplicated values from a vector, you can just index the vector by \texttt{!duplicated}:

<<>>=
vec[!duplicated(vec)]
@

However, you can do the same thing with \texttt{unique()}!

 
\end{itemize}


\section{A worked example - Chicken Weights}

A farmer is testing the effectiveness of three different diets on the weight gain of chickens. When they are born, 50 chicks are randomly assigned to one of 4 diets. Over several time periods, the farmer weighs each chicken. These data are contained in the dataset \texttt{ChickWeight}. Because the data are stored in a dataframe, which we haven't learned yet, we'll convert the four columns in the dataset to vectors as follows:

<<>>=
weights <- ChickWeight$weight
time <- ChickWeight$Time
chick <- as.numeric(paste(ChickWeight$Chick))
diet <- as.numeric(ChickWeight$Diet)
@

Let's answer 5 questions with these vectors:

\begin{enumerate}

  \item What are the first 10 elements of the \texttt{weights} vector and the last 10 elements of the \texttt{weights} vector?\marginnote{To answer the second question, I used the \texttt{length()} function to index index \texttt{weights} to go from 9 elements \textit{before} the end of the vector, to the end of the vector.}
  
<<>>=
weights[1:10]
weights[(length(weights) - 9):length(weights)]
@
  
  \item Which chicks were given diets 1 and 2?
  
<<>>=
unique(chick[diet == 1])
unique(chick[diet == 2])
@

  \item What was the mean weight across all time periods separately for diets 3 and 4?\marginnote{First, I indexed the \texttt{weights} vector with a logical vector created from from \texttt{diet}. I then calculated the mean of this indexed vector.}
  
<<>>=
mean(weights[diet == 3])
mean(weights[diet == 4])
@

  \item What was the standard deviation of weights for diets 1 and 2 at time < 10?
  
<<>>=
sd(weights[diet <= 2 & time < 10])
@

  \item What was the median weight for chicks 10, 20, and 30 for time periods greater than 10?
  
<<>>=
median(weights[chick %in% c(10, 20, 30) & time > 10])
@

  \item Which chicks did not make it until the final time period?\marginnote{This one is a bit tricky. First, I need a vector of all chicks in the study (\texttt{all.chicks}). Next, I need a vector of all chicks that survived to the last time point (\texttt{surviving.chicks}). Third, I need to test, for each chick, whether they are present in the vector of surviving chicks (\texttt{survived.log}). Finally, I index the vector of all chicks where the logical index is FALSE (because we want chicks that did not survive).}

<<>>=
# Step 1: Create a vector of all chicks (all.chicks)
all.chicks <- sort(unique(chick))

#Step 2: Create a vector of all chicks that survive until the end (surviving.chicks)
surviving.chicks <- sort(unique(chick[time == max(time)]))

# Step 3: For each chick, see if it is present in the vector of surviving chicks
survived.log <- all.chicks %in% surviving.chicks

# Step 4: Index the vector of all chicks by the logical vector
all.chicks[survived.log == FALSE]
@

\end{enumerate}



\end{itemize}

%----------------------------------------------------------------------------------------
%	CHAPTER 5
%----------------------------------------------------------------------------------------

\chapter{5: Matrices and Data Frames}}
\label{ch:5}


Chapter Goals


\begin{enumerate}
  \item Learn about the matrix and dataframe data objects
  \item Create matrices with matrix(), cbind(), and data.frame()
  \item Index matrices/dataframes with brackets [], and \$
  \item Use matrix/dataframe functions dim(), nrow(), ncol(), head(), tail()
  \item Import datasets
\end{enumerate}
 

\section{Creating matrices and dataframes}

By now, you should be comfortable with scalars and vectors. Next, we'll cover the next two most common data objects in R, \textbf{matrices} and \textbf{dataframes}

Matrices and dataframes are both two dimensional objects that contain rows and columns. Really, they're just like spreadsheets in Excel. Each matrix or dataframe contains a certain number of rows (call that number m) and columns (n). You can think of a matrix as a combination of n vectors, where each vector has a length of m. See Figure \ref{fig:scalarvectormatrix} to see the difference.


\begin{marginfigure}
\begin{tiny}
<<fig.height = 3.2, fig.width = 5>>=
# scalar v vector v matrix

par(mar = rep(1, 4))
plot(1, xlim = c(0, 10), ylim = c(-.5, 5), 
     xlab = "", ylab = "", 
     xaxt = "n", yaxt = "n", 
     bty = "n", type = "n")

# scalar
rect(rep(0, 1), rep(0, 1), rep(1, 1), rep(1, 1))
text(.5, -.5, "scalar")

# Vector
rect(rep(2, 5), 0:4, rep(3, 5), 1:5)
text(2.5, -.5, "Vector")

# Matrix
rect(rep(4:8, each = 5), 
     rep(0:4, times = 5), 
     rep(5:9, each = 5), 
     rep(1:5, times = 5))
text(6.5, -.5, "Matrix / Data Frame"
     )
@
\caption{scalar, Vector, Matrix... ::drops mike::}
\label{fig:scalarvectormatrix}
\end{tiny}
\end{marginfigure}

You can use several functions in R to create matrices and dataframes. In the next sections we'll cover the most common ones.

\subsection{cbind() and rbind()}

\texttt{cbind()} and \texttt{rbind()} both create matrices by combining several vectors together into a single matrix. cbind() combines vectors as columns in the matrix, while rbind() combines them as rows.



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{cbind(), rbind()}\index{cbind()}\index{rbind()}

\hline

\begin{description}

  \item[\tt{x, y, ...}] \hfill \\
      One or more vectors to be combined into a matrix
\end{description}

}
}
\vspace{5mm} %5mm vertical space

Let's use these functions to create a matrix with the numbers 1 through 30. First, we'll create three vectors of length 10, then we'll combine them into one matrix.

\begin{footnotesize}
<<>>=
x <- 1:10
y <- 11:20
z <- 21:30

matrix.1 <- rbind(x, y, z)
matrix.1

matrix.2 <- cbind(x, y, z)
matrix.2
@
\end{footnotesize}

As you can see, the \texttt{rbind()} function combined the vectors as rows in the final matrix, while the \texttt{cbind()} function combined them as columns.

If you want to create a matrix from a single vector of data, you can do this using the \texttt{matrix()} function.


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{matrix()}\index{matrix()}

\hline

\begin{description}

  \item[\tt{data}] \hfill \\
      A vector of data
        \item[\tt{nrow}] \hfill \\
      The number of rows in the final matrix
        \item[\tt{ncol}] \hfill \\
      The number of columns in the final matrix
        \item[\tt{byrow}] \hfill \\
      A logical value indicating whether to fill the matrix by row or column
\end{description}

}
}
\vspace{5mm} %5mm vertical space


Let's use the \texttt{matrix()} function to re-create a matrix containing the values from 1 to 30.

\begin{footnotesize}
<<>>=
matrix.1 <- matrix(data = 1:30, 
                   nrow = 10, 
                   ncol = 3)
matrix.1

matrix.2 <- matrix(data = 1:30, 
                   nrow = 3, 
                   ncol = 10)
matrix.2
@
\end{footnotesize}

Keep in mind that matrices can either contain numbers or characters. If you try to create a matrix with both numbers and characters, it will turn all the numbers into characters:

\begin{footnotesize}
<<>>=
cbind(1:5, c("a", "b", "c", "d", "e"))
@
\end{footnotesize}

\subsection{Dataframe: An m x n object containing numbers, strings and factors}

A dataframe looks a lot like a matrix at first: it is also rectangular and has m rows and n columns. However, unlike matrices, dataframes can contain *both* string vectors and numeric vectors within the same object. For this reason, most large datasets in R, for example, a survey including numeric data and text data, will be stored as dataframes.

\marginnote{A dataframe is just a more flexible matrix that allows you to combine both character and numeric vectors into the same data object. Because dataframes are more flexible than matrices, Most datafiles you use will be stored as dataframes.}

\newfun{data.frame()}\index{data.frame()}

To create a dataframe, you can use the \texttt{data.frame()} function. Let's create a dataframe of fictional survey data. I'll create 5 entries for Males and 5 entries for Females. I'll then generate 10 heights from a normal distribution with mean 150 and standard deviation 10.

\begin{footnotesize}
<<>>=
survey <- data.frame("gender" = rep(c("Female", "Male"), each = 10),
                     "height" = rnorm(20, mean = 150, sd = 10),
                     stringsAsFactors = F # don't convert strings to factors
                    )
survey # Print the dataframe
@
\end{footnotesize}

You'll notice I included the argument \texttt{stringsAsFactors = F}, this tells R to NOT convert the strings (the Gender column) to a factor datatype. For now, don't worry about what factors are. Just know that you don't want to use them just yet!

\section{Data sets pre-loaded in R}

Until now, we've used the functions \texttt{matrix()} and \texttt{dataframe()} to manually create our own datasets within R. However, for demonstration purposes, it's frequently easier to use existing datasets. Thankfully, R has us covered: R has several datasets that come pre-installed in a package called \texttt{datasets}. While you probably won't make any major scientific discoveries with these datasets, they allow all R users to test and compare code on the same sets of data.\marginnote{To see a complete list of all the datasets included in the \texttt{datasets} package, run the code: \texttt{library(help = "datasets")}} Here are a few datasets that we will be using in future examples:

\begin{itemize}
  \item \texttt{ChickWeight}: Weight versus age of chicks on four different diets
  \item \texttt{InsectSprays}: Effectiveness of six different types of insect sprays
  \item \texttt{ToothGrowth}: The effects of different levels of vitamin C on the tooth growth of guinea pigs.
\end{itemize}

Since these datasets are preloaded in R, you can always access them by by name. We'll use them in the following examples.

\section{Viewing matrices and dataframes}

When you start working with a new dataset loaded as a matrix or dataframe, you'll usually want to get a quick visual look at it to make sure it looks ok. There are two functions that I use to do this:

\newfun{head(x)}\index{head()}

The function \texttt{head(x)} will show you the first few rows of a matrix / dataframe. Personally, I am constantly using this function to make sure that I didn't screw up a dataset when I'm working on it. Let's look at the first few rows of the dataframe \texttt{ChickWeight}, which contains data on the growth of chickens on several different diets.

<<>>=
head(ChickWeight)
@

The \texttt{head()} function only shows you the first few rows of a dataframe, but usually this is enough to get a visual sense of the names of the dataframe, the number of columns, and the type of data in each column. But what if you want to see all values? You could print the entire dataframe into the console, but the console isn't a very friendly environment to view data. Instead, you can use the \texttt{View()} function, which will print the entire dataframe into a spreadsheet-like window:

\newfun{View(x)}\index{View()}

Let's use the \texttt{View()} function to look at the entire \texttt{ToothGrowth} dataframe:

<<eval = F>>=
View(ToothGrowth)
@

When you run this code, you should see a separate window open (see Figure~\ref{fig:toothgrowthscreenshot}). You can use this window to scroll through the data, sort it via column values (by clicking on the column name), and even apply filters using the filter button on the top left of the screen. However, keep in mind that anything you do in the \texttt{View()} window will \textit{not} change the actual dataframe in any way. You cannot add or remove data using the window, and any sorting or filtering you apply won't be replicated in the actual data.

\begin{figure}[h]
\includegraphics[width=10cm,keepaspectration]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/toothgrowthscreenshot.png}
\label{fig:toothgrowthscreenshot}
\caption{Screenshot of the window from \texttt{View(ToothGrowth)}. You can use this window to visually sort and filter the data to get an idea of how it looks, but you can't add or remove data and nothing you do will actually change the dataframe.}
\end{figure}

\section{Loading data into R with read.table()}

So far we've used either randomly generated data, or datasets pre-loaded in R. But how do you get an existing dataset into R? For the most part, getting datasets into R isn't that tricky - but only if your data is already in a 'nice' format. By 'nice,' I mean a text file with tab (or comma) separated columns. If your data is in another format (like Excel or Shitty Piece of Shitty Shit), I strongly recommend first exporting the data to a tab-delimited text file, and only then loading the data into R. That said, if for some reason you absolutely have to load a non-text file into R, look at the \textit{Additional Tips} sections for instructions.\marginnote{Import data into R as comma or tab-delimited text files whenever possible. If you need to load data in another format (e.g.; Excel), save it as a text file from the original program first.}

Once you have a text file, you can load it into R using the \texttt{read.table()} function. To use the \texttt{read.table()} function, you need to know where the text file is located on your computer. To do this, find the file on your harddrive then right-click it and view its properties. You should be able to see its file-path there. For example, the file path of a text file called \texttt{mydata} on my desktop is \texttt{"Users/Nathaniel/Desktop/mydata.txt"}.

Here are the main arguments to \texttt{read.table()} (to see all of them, run \texttt{?read.table})



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{read.table()}\index{readltab.e()}

\hline

\begin{description}

  \item[\tt{file}] \hfill \\
      The document's file path (make sure to enter as a string with quotation marks!) OR an html link to a file.
        \item[\tt{header}] \hfill \\
      A logical value indicating whether the data has a header row or not.
        \item[\tt{ncol}] \hfill \\
      The number of columns in the final matrix
        \item[\tt{sep}] \hfill \\
      A string indicating how the columns are separated. For comma separated files, use \texttt{","}, for tab-delimited files, use \texttt{"\textbackslash t"}
      \item[\tt{stringsAsFactors}] \hfill \\
     A logical value indicating whether or not to convert strings to factors. I always set this to FALSE (because I don't like using factors)
\end{description}

}
}
\vspace{5mm} %5mm vertical space


To test this function, let's read in the datafile called \texttt{Flights.txt}. This dataset contains data on all flights leaving the Houston airport in 2011. You can access this data in one of two ways: First, you can download this file from: http://nathanieldphillips.com/wp-content/uploads/2015/04/Flights.txt) and a note of its directory on your computer (on my computer, the path is \texttt{/Users/Nathaniel/Dropbox/Public/Flights.txt}). You can then load the data into R by using \texttt{read.table}:

\begin{footnotesize}
<<eval = T>>=
Flights <- read.table(file = "/Users/Nathaniel/Dropbox/Public/Flights.txt",
                      header = T,
                      sep = "\t", # tab-delimited
                      stringsAsFactors = F
                      )
@
\end{footnotesize}

If you receive an error, it's probably because you entered the file path incorrectly. One trick to get the file path easily is by using RStudio's \textbf{Import Dataset} menu (see \textit{Additional Tips}). If you got the directory location correct, and the file exists, then you should not receive any error warning after executing \texttt{read.table()}.

Alternatively, you can load the dataset directly into R by entering the HTML link as the \texttt{file} argument to \texttt{read.table}

\begin{footnotesize}
<<eval = F>>=
Flights <- read.table(file = "http://nathanieldphillips.com/wp-content/uploads/2015/04/Flights.txt",
                      header = T,
                      sep = "\t", # tab-delimited
                      stringsAsFactors = F
                      )
@
\end{footnotesize}

The data is now stored as a dataframe and you can now access it via the object name you assigned it to (in my case, I called it \texttt{Flights}). To make sure it loaded correctly, try seeing the first few rows with \texttt{head()}

\begin{footnotesize}
<<>>=
head(Flights)
@
\end{footnotesize}

\subsection{Additional tips}

\begin{itemize}
  \item If you're like me, and you hate figuring out (and typing) the directory of a file, you can use RStudio's menu to help you. If you click on the Environment window and click the button \texttt{Import Dataset}, you'll activate a menu that will allow you to select the file using your computer's finder. You'll then be greeted with a graphical interface for setting the import parameters. When you are finished, RStudio not only import the dataset, but it will paste the R code needed to import the data into the console. You can then copy the code (which includes the file path) and paste it into your R document so the next time you use the document you can just run the code to import the data.
  \item There are many functions other than \texttt{read.table()} for importing data. For example, the functions \texttt{read.csv} and \texttt{read.delim} are specific for importing comma-separated and tab-separated text files. In practice, these functions do the same thing as \texttt{read.table}, but they don't require you to specify a \texttt{sep} argument. Personally, I always use \texttt{read.table()} because it always works and I don't like trying to remember unnecessary functions.
  \item If you absolutely have to read a non-text file into R, check out the package called \texttt{foreign}. This package has functions for importing Stata, SAS and Shitty Piece of Shitty Shit files directly into R. To read Excel files, try the package \texttt{xlsx}

\end{itemize}

%----------------------------------------------------------------------------------------
%	CHAPTER 6
%----------------------------------------------------------------------------------------

\chapter{6: Basic Dataframe Manipulation}
\label{ch:6}


Chapter Goals

\begin{enumerate}
  \item Getting basic information about dataframes: dim(), nrow(), ncol(), summary()
  \item Indexing dataframes with brackets [,], and \$
  \item Subsettting dataframes with logical indexing and subset()
  \item Recoding values in a dataframe with indexing
\end{enumerate}

In this chapter we'll cover how to do some basic analyses on dataframes. We'll focus on dataframes, and not on matrices, because most datasets you use will be stored as dataframes. However, if you do find yourself working with matrices, many of the techniques you'll learn in this chapter will also apply to them.


\section{Getting information about matrices and dataframes}

When you are working with dataframes, you will frequently want to know its general attributes, such as the number of rows and columns it has. Here are some common functions to get basic information about a dataframe:

\begin{itemize}
  \item dim(x): Number of rows and columns in a dataframe x (returns a vector of length 2)
  \item nrow(x) ncol(x): How many rows or columns are there in a dataframe x (each function returns a scalar)
  \item summary(x): Summary of information about each column in a dataframe x
\end{itemize}


\begin{footnotesize}
<<>>=
dim(survey) # How many rows and columns?
nrow(survey) # How many rows?
ncol(survey) # How many columns?
summary(survey) # Summary information on each column
@
\end{footnotesize}

While you might not see the benefits of these functions now, they will become invaluable later if you conduct simulations on datasets.

Next let's start with the basics of indexing dataframes using brackets.

\section{Indexing dataframes with brackets [rows, columns]}

Just like vectors, you can access specific data in dataframes using brackets. But now, instead of just using one indexing vector, we use two indexing vectors: one for the rows and one for the columns. To do this, use the notation \texttt{data[rows, columns]}, where \texttt{rows} and \texttt{columns} are scalars or vectors of the row and column numbers you want to get.

Let's try this on the \texttt{ChickWeight} dataframe that comes with R.

\begin{marginfigure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/chickweight.jpg}
\caption{I tried ordering a vegan alternative at a traditional German restaurant and this is what I got.}
\label{fig:chickweight}
\end{marginfigure}

\begin{footnotesize}
<<>>=
ChickWeight[1:5, 1] # Give me rows 1 through 5 in column 1
ChickWeight[2:6, 2:3] # Give me rows 2 through 6 in columns 2 and 3
ChickWeight[seq(from = 1, to = nrow(ChickWeight), by = 10), 3] # Give me every 10th row in the 3rd column
@
\end{footnotesize}
\marginnote{Here you can see the benefits of using \texttt{nrow()} - I used it to make sure I gave valid index values to \texttt{ChickWeight}}

If you want an entire row or column, you can simply leave one of the indices blank. For example, if I want the entire first row of \texttt{ChickWeight} and all of the columns, I can simply leave the column index blank:

\begin{footnotesize}
<<>>=
ChickWeight[1,]
@
\end{footnotesize}

You can use the same logic to get an entire column of a dataframe by leaving the index for rows blank. If you leave both index values blank, you'll get the entire dataframe back.

\subsection{Accessing dataframe columns by column name and \$}

One of the nice things about dataframes is that each column will have a name. You can then use this name to access specific columns without having to index columns by numbers. To access the names of a dataframe, use the function \texttt{names()}. This will return a string vector with the names of the dataframe.

Let's use \texttt{names()} to get the names of some of the dataframes stored in R.

\begin{footnotesize}
<<>>=
names(ChickWeight)
names(InsectSprays)
names(ToothGrowth)
@
\end{footnotesize}

To access a specific column in a dataframe by name, you use the the \texttt{\$} operator:

\newfun{dataframe\$colname}

where \texttt{dataframe} is the name of the dataframe, and \texttt{colname} is the name of the column you are interested in. When you apply the \texttt{\$} operator to a dataframe, it will return a vector. Let's access some of the vectors in the dataframes \texttt{ChickWeight}, and \texttt{ToothGrowth}

\begin{footnotesize}
<<>>=
ChickWeight$weight[1:20] # Just the first 20 values
ToothGrowth$len
@
\end{footnotesize}

Because the \$ operator returns a vector, you can easily calculate descriptive statistics on columns of a dataframe using \$:

\begin{footnotesize}
<<>>=
mean(ChickWeight$weight)
median(ToothGrowth$len)
@
\end{footnotesize}

\section{Adding new columns to a dataframe}

You can easily add columns to a dataframe using the \texttt{\$} and assignment \texttt{<-} operators. To do this, just use the \texttt{dataframe\$colname} notation and assign a new vector to it. Let's test this by adding a new column to \texttt{ChickWeight} called \texttt{height} which indicates the height of each chick at each time point. Now, because I don't have the actual height data, I'll just sample some random data from a normal distribution with mean 5 and standard deviation 1.

\begin{footnotesize}
<<>>=
ChickWeight$height <- rnorm(n = nrow(ChickWeight), mean = 5, sd = 1)
@
\end{footnotesize}

Let's look at the first few rows of \texttt{ChickWeight} to make sure it worked:

\begin{footnotesize}
<<>>=
head(ChickWeight)
@
\end{footnotesize}

As you can see, the \texttt{ChickWeight} dataframe now has a column named \texttt{height} with the random data we generated.

Of course, because columns of dataframes are just vectors, you can add columns that are some function of existing columns. For example, let's add a column to \texttt{ChickWeight} called \texttt{density} which we'll define as each chick's height divided by its weight:

\begin{footnotesize}
<<>>=
ChickWeight$density <- ChickWeight$height / ChickWeight$weight
head(ChickWeight)
@
\end{footnotesize}

When you are conducting analyses on dataframes, it's important that you always repeat the name of the dataframe when accessing its columns. If you don't, R will assume the column name is a totally different object. For example, the following code \textit{won't work} because R thinks that \texttt{height} and \texttt{weight} are totally separate objects from \texttt{ChickWeight}}

\begin{footnotesize}
<<eval = F>>=
ChickWeight$density <- height / weight # BAD CODE!
@
\end{footnotesize}

However, there is a function \texttt{with()} that can help prevent you from having to repeat the name of a dataframe over and over again.

\newfun{with(x, ...)}\index{with()}

\marginnote{\texttt{with(x, ...)}: Simplifies your code for dataframe manipulation by allowing you to just enter the name of the dataframe once.}

The function \texttt{with()} allows you to specify a dataframe (or any other object in R) once, and R will assume you're referring to that object in an expression.

For example, let's repeat the \texttt{ChickWeight\$density} calculation using \texttt{with()}. We'll set the name of the dataframe as the first argument, then do our regular calculations on the column names.

\begin{footnotesize}
<<>>=
ChickWeight$density <- with(ChickWeight, height / weight)
@
\end{footnotesize}

As you can imagine, if you're performing a long set of calculations on many columns of a dataframe, the \texttt{with()} function can save you lots of typing!


\section{Centering and standardizing (z-score) data}

Centering and standardizing are two common methods of transforming data. Centering data simply means transforming the data so that the mean is 0, while standardizing data means centering the data and dividing all data points by the standard deviation of the data. Here's how to do each:

\subsubsection{Centering}

Centering data is quite easy. All you need to do is calculate the mean of a vector, then subtract that mean from all data in the vector.

Generally, if we have a dataframe called \texttt{df}, and we want to center a column called \texttt{x}, we'd run the following code:

<<eval = F>>=
df$x.centered <- with(df, x - mean(x))
@

Let's use this method to center the weight data from \texttt{ChickWeight} - we'll call the new column \texttt{weight.c}

\begin{footnotesize}
<<>>=
ChickWeight$weight.c <- with(ChickWeight, weight - mean(weight))
@
\end{footnotesize}

To see if this worked, let's compare the mean of \texttt{weight} and \texttt{weight.c}

\begin{footnotesize}
<<>>=
mean(ChickWeight$weight)
mean(ChickWeight$weight.c)
@
\end{footnotesize}

I know what you're thinking...``But wait!!! The mean of \texttt{ChickWeight\$weight.c} isn't exactly 0!!!'' Don't worry, \texttt{-1.2919e-15} is -0000000000000012919. For all intents and purposes, that's equal to 0 - the reason it's not \textit{exactly} 0 is due to peculiarities about how computers represent numbers. Don't ask me why, I'm just a pirate.

\subsubsection{Standardizing}

Standardizing data is almost as easy as centering. The only difference is that, in addition to subtracting the mean from the data, we need to divide the data by its standard deviation. If you have a dataframe \texttt{df} and you want to standardize a column \texttt{x} into a new column called \texttt{x.z}, we use the following code:

<<eval = F>>=
# Create a standardized version of column x in a dataframe df
df$x.z <- with(df, (x - mean(x)) / sd(x))
@

Let's use this method to standardize the weight data from \texttt{ChickWeight} - we'll call the new column \texttt{weight.z}

\begin{footnotesize}
<<>>=
ChickWeight$weight.z <- with(ChickWeight, (weight - mean(weight)) / sd(weight))
@
\end{footnotesize}

To see if this worked, let's compare the mean of \texttt{weight}, \texttt{weight.c}, and \texttt{weight.z}. The mean of \texttt{weight.z} should be 0 and its standard deviation should be 1:

\begin{footnotesize}
<<>>=
c(mean(ChickWeight$weight), sd(ChickWeight$weight))
c(mean(ChickWeight$weight.c), sd(ChickWeight$weight.c))
c(mean(ChickWeight$weight.z), sd(ChickWeight$weight.z))
@
\end{footnotesize}


\section{Subsetting dataframes with logical indexing and subset()}

Frequently you will want to access specific rows of a dataframe based on some criteria - this is called subsetting. For example, we may want to look just at the data from females in our survey data. To do this, we can use one of two methods: indexing with logical vectors, or the \texttt{subset()} function.

Indexing dataframes with logical vectors is very similar to indexing data vectors. First, we create a logical vector. Next, we index the dataframe using that logical vector. Let's use indexing to access just the data from Chick 1 in \texttt{ChickWeight}:

\begin{footnotesize}
<<>>=
chick1.log <- ChickWeight$Chick == 1 # Step 1: Create a logical vector
chick1.data <- ChickWeight[chick1.log,] # Step 2: Index dataframe by logical vector
chick1.data # Print the result
@
\end{footnotesize}

If you'd like, you can also combine the two steps in one line. For example, the following code gives the same result as the previous:

\begin{footnotesize}
<<>>=
chick1.data <- ChickWeight[ChickWeight$Chick == 1, ] # Two steps in 1
@
\end{footnotesize}

Now, let's try indexing the \texttt{ChickWeight} data using a slightly more complicated index. For example, let's access just the data for the chicks where \texttt{Time} is less than 10

\begin{footnotesize}
<<>>=
ChickWeight.lt10 <- ChickWeight[ChickWeight$Time < 10,]
head(ChickWeight.lt10)
@
\end{footnotesize}

Indexing with brackets is the standard way to slice and dice dataframes. However, if you are working on data that is all in the same dataframe, it can get a bit tiresome to have to constantly repeat the name of the dataframe. For example, let's say we wanted to get data from \texttt{ChickWeight} where \texttt{Time < 10} and \texttt{Diet == 1}. The following code works, but it's a bit tedious:

\begin{footnotesize}
<<>>=
mydata <- ChickWeight[ChickWeight$Time < 10 & ChickWeight$Diet == 1,]
@
\end{footnotesize}

A way to get around having to repeat the name of the dataframe over and over is to use the \texttt{subset()} function.



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{subset()}\index{subset()}

\hline

\begin{description}

  \item[\tt{x}] \hfill \\
      The data (usually a dataframe)
        \item[\tt{subset}] \hfill \\
      A logical vector indicating which rows you want to select
        \item[\tt{select}] \hfill \\
      An optional vector of the columns you want to select
       
\end{description}

}
}
\vspace{5mm} %5mm vertical space

For example, let's get the \texttt{ChickWeight} data for \texttt{Diet == 1} and \texttt{Time > 15}

\begin{footnotesize}
<<>>=
data <- subset(x = ChickWeight, 
               subset = (Diet == 1 & Time > 15)
               )
head(data)
@
\end{footnotesize}

In the example above, I didn't specify an input to the \texttt{select} argument because I wanted all columns. However, if you just want certain columns, you can just name the columns you want. For example, let's say I just want the \texttt{weight} and \texttt{Time}
 columns from the previous analysis. To do this, I'll just add the column names as inputs to the \textt{select} argument:
 
 \begin{footnotesize}
<<>>=
data <- subset(x = ChickWeight, 
               subset = (Diet == 1 & Time > 15),
               select = c(weight, Time)
               )
head(data)
@
\end{footnotesize}
 
\section{Combining indexing and descriptive statistics}

Once you know how to index a dataframe to get the data vectors you want, you can then easily calculate descriptive statistics based on specific criteria. For example, let's calculate the mean weight of the chicks on \texttt{Diet == 1}. To show you that there are many ways to do this, I'll write the code in three different ways:

\begin{footnotesize}
<<>>=
# What is the mean weight of chicks on the first diet?

mean(ChickWeight$weight[ChickWeight$Diet == 1]) # Using logical indexing
with(ChickWeight, mean(weight[Diet == 1])) # Logical indexing and with()
mean(subset(x = ChickWeight, subset = Diet == 1)$weight) # Using subset()
@
\end{footnotesize}

As you can see, there are many ways to do the same thing in R. Ultimately, the choice of which specific code and functions you use is up to you.

\section{A worked example: Credit default}

For this example, we'll work with a dataset called \texttt{credit}. This dataset contains information about German loan borrowers (IVs) and whether or not the borrower defaulted on their loan (DV). To load the dataset, either download and load the data from the link \texttt{http://goo.gl/a7umut}, or simply run the following code:

\begin{footnotesize}
<<>>=
credit <- read.table("http://nathanieldphillips.com/wp-content/uploads/2015/05/credit.csv", 
                     sep = ",", header = T, stringsAsFactors = F)
@
\end{footnotesize}

Here is a screenshot of the dataset:

\begin{footnotesize}
<<eval = F>>=
View(credit)
@
\end{footnotesize}

\begin{figure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/creditscreenshot.png}
\caption{Screenshot of the credit dataset.}
\label{fig:creditscreen}
\end{figure}

The dataset has 17 total columns - to see their names, execute \texttt{names(credit)}

\begin{footnotesize}
<<>>=
names(credit)
@
\end{footnotesize}

Let's answer 5 questions with this dataset:

\begin{enumerate}

  \item Was there a relationship between the size of the loan and whether or not it defaulted?
  
    
\begin{marginfigure}
\begin{tiny}
<<>>=
amount.default <- credit$amount[credit$default == "yes"]
amount.nodefault <- credit$amount[credit$default == "no"]

require(beanplot)

beanplot(amount ~ default, data = credit, 
         col = c("white", gray(.8), gray(.8), "black"),
         names = c("No", "Yes"),
         main = "Loan size by default",
         xlab = "Did the loan default?",
         ylab = "Loan size (log-transformed)",
         what = c(1, 1, 1, 0)
         )

@
\end{tiny}
\caption{Distributions of loan sizes separated for loans that defaulted and those that did not.}
\label{fig:creditbeans}
\end{marginfigure}
  
\begin{footnotesize}
<<>>=
amount.default <- credit$amount[credit$default == "yes"]
amount.nodefault <- credit$amount[credit$default == "no"]

summary(amount.default)
summary(amount.nodefault)
@
\end{footnotesize}

We calculated the median loan size separately for people whose loans defaulted and those whose loans did not default. The loan amounts of loans that defaulted (median of \Sexpr{round(median(amount.default), 0)}) tended to be a bit larger than those that did not (median of \Sexpr{round(median(amount.nodefault), 0)}). However, looking at the full amount distributions (see Figure~\ref{fig:creditbeans}), it is unclear if the difference is really very meaningful.
  
  \item Was the age of the borrower related to the loan amount?
  
\begin{marginfigure}
\begin{tiny}
<<fig.height = 4, fig.width = 4>>=
# Main Plot
plot(credit$age, credit$amount, 
     pch = 16, col = gray(.5, alpha = .2),
     main = "Loan amount by borrower age",
     xlab = "Borrower Age", ylab = "Loan Amount (DM)"
     )

par(xpd=NA)
segments(25, 20000, 35, 20000, col = "red", lwd = 2)
text(50, 20000, "5 year average")

# Create factor from age
age.cut <- cut(credit$age, breaks = seq(20, 70, 5))

# Determine mean loan by age factor
amount.cut <- tapply(credit$amount, age.cut, mean)

# Add mean lines
lines(seq(22.5, 67.5, 5), amount.cut, 
      col = "red", lwd = 2, type = "b", pch = 16)

@
\end{tiny}
\caption{Distributions of loan sizes as a function of the age of the borrower.}
\label{fig:creditscatter}
\end{marginfigure}
  
\begin{footnotesize}
<<>>=
summary(credit$amount[credit$age <= median(credit$age)])
summary(credit$amount[credit$age > median(credit$age)])

cor(credit$age, credit$amount)
@
\end{footnotesize}
  
  To answer this, we separately calculated the median loan amount for borrowers below and above the median age (of \Sexpr{round(median(credit$age), 2)}). Borrowers below the median age had a median loan amount of \Sexpr{round(median(credit$amount[credit$age <= median(credit$age)]), 0)}, while borrowers above the median age had a median loan amount of \Sexpr{round(median(credit$amount[credit$age > median(credit$age)]), 0)}. This suggests that age was unrelated to loan amount. Examining the scatterplot in Figure~\ref{fig:creditscatter}, we do not find strong evidence for an effect of borrower age on loan amount. 
  
  \item Was there a relationship between whether or not someone had a phone and whether or not their loan defaulted?
  
\begin{footnotesize}
<<>>=
with(credit, table(phone, default))
with(credit[credit$phone == "yes",], mean(default == "yes"))
with(credit[credit$phone == "no",], mean(default == "yes"))
@
\end{footnotesize}

We separately the proportion of people who defaulted on their loans separately between those who own a phone and those who do not. We found that people without a phone were slightly more likely to default (\Sexpr{100 * round(with(credit[credit$phone == "no",], mean(default == "yes")), 4)}\%) than people with a phone (\Sexpr{100 * round(with(credit[credit$phone == "yes",], mean(default == "yes")), 4)}\%) (a \texttt{mosaic.plot} of the data is presented in margin Figure~\ref{fig:phoneloan}).
  
  
\end{enumerate}


\subsection{Additional Tips}

\begin{itemize}
  \item If you want to change the names of columns in a dataframe, you can do this by reassigning elements of the \texttt{names()} function. For example, let's change the names of the first two columns of our dataframe \texttt{survey} to "Sex" and "Height.cm"


\begin{marginfigure}
  \begin{tiny}
<<fig.height = 4, fig.width = 4>>=
require(RColorBrewer)
with(credit, mosaicplot(table(phone, default), 
                  main = "Phone Ownership and Loan Default", 
                  xlab = "Own Phone?",
                  ylab = "Loan Default?", color = brewer.pal(12, "Set3")[5:4]
     ))

defper.withphone <- mean(credit$default[credit$phone == "yes"] == "yes")
defper.nophone <- mean(credit$default[credit$phone == "no"] == "yes")

text(mean(credit$phone == "no") / 2,
     defper.nophone / 2,
     paste(100 * round(defper.nophone, 2), "%", sep = "")
     )

text(1 - mean(credit$phone == "yes") / 2,
     defper.withphone / 2,
     paste(100 * round(defper.withphone, 2), "%", sep = "")
     )
@
  \end{tiny}
  \label{fig:phoneloan}
  \caption{Mosaic plot of the contingency between phone ownership and loan defaults in the \texttt{credit} dataset. People who own a phone are slightly less likely to default on their loans that people who do not own a phone.}
  \end{marginfigure}


\begin{footnotesize}
<<>>=
names(survey)
names(survey)[1:2] <- c("Sex", "Height.cm")
names(survey)
@
\end{footnotesize}

  
  



\end{itemize}
%----------------------------------------------------------------------------------------
%	CHAPTER 7
%----------------------------------------------------------------------------------------

\chapter{7: Plotting Basics}
\label{ch:7}

Chapter Goals

\begin{enumerate}
  \item High-level plotting commands: plot(), hist(), boxplot, barplot()
  \item Main plotting parameters: main, xlab, ylab, xlim, ylim
  \item Low-level plotting functions: abline(), points(), text(), legend()
  \item Saving plots with pdf() and jpg()
\end{enumerate}

Sammy Davis Jr.\index{Sammy Davis Jr.} was one of the greatest performers of all time. If you don't know him already, Sammy was an American entertainer who lived from 1925 to 1990. The range of his talents was just incredible. He could sing, dance, act, and play multiple instruments with ease. So how is R like Sammy Davis Jr? Like Sammy Davis Jr., R is incredibly good at doing many different things. R does data analysis like Sammy dances, and creates plot like Sammy sings. If Sammy and R did just one of these things, they'd be great. The fact that they can do both is pretty amazing.

\begin{marginfigure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/sammy.jpg}
\caption{The great Sammy Davis Jr. Do yourself a favor and spend an evening watching videos of him performing on YouTube. Image used entirely without permission.}
\label{fig:sammy}
\end{marginfigure}

Plotting in R works like putting paint on a canvas. You start by creating a canvas and plotting the main elements using a \textit{high-level} plotting command. In these high-level plotting commands, you specify things like the x and y coordinates of the plot, the plot titles, and the main data in the plot. Next, you use \textit{low-level} plotting commands to sequentially add as many additional individual elements as you'd like, from lines to arrows to text. Once you are done, you can export the plot as a jpg or pdf file. In the next section, we'll cover the most common high-level plotting functions


\section{High-level plotting functions}

The most common high-level plotting function is \texttt{plot(x, y)}. While its name sounds like it can make any kind of plot, the \texttt{plot()} command creates a scatterplot from two vectors x and y:
\marginnote{\texttt{plot(x, y)}: Create a scatterplot from two vectors x and y.\\ \texttt{main}: Title of plot \\ \texttt{xlab, ylab}: axes labels \\ \texttt{xlim, ylim}: Limits of axes \\ \texttt{xaxt, yaxt}: Set to \texttt{"n"} to remove the axes \\ \texttt{cex}: Size of the plotting points \\ \texttt{pch}: Type of plotting points (see \texttt{?points})}




\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{plot()}\index{plot()}

\hline

\begin{description}

  \item[\tt{x, y}] \hfill \\
  Two vectors of data on the x and y-axes
    \item[\tt{main}] \hfill \\
 The title of the plot
    \item[\tt{xlab, ylab}] \hfill \\
  Labels for the x and y-axes.
    \item[\tt{xlim, ylim}] \hfill \\
 A vector of length two containing the minimum and maximum values of the x and y-axes. For example: \texttt{xlim = c(0, 100), ylim = c(50, 60)} will set the x limits to [0, 100] and the ylimitx to [50, 60].
    \item[\tt{col}] \hfill \\
    The color of the plotting points. For example \texttt{col = "red"} will create red plotting points.
\item[\tt{pch}] \hfill \\
    An integer indicating the type of plotting symbols (see \texttt{?points} and section below), or a string specifying symbols as text.
\item[\tt{cex}] \hfill \\
  The size of the symbols (from 0 to Inf). The default size is 1.
\item[\tt{type}] \hfill \\
The type of plot. Use \texttt{"p"} for points (the default), \texttt{"l"} for lines, \texttt{"b"} for points and lines, and \texttt{"\textbackslash n"} for no plotting


\end{description}

}
}
\vspace{5mm} %5mm vertical space


The \texttt{plot()} function, like many plotting functions, has several optional arguments that allow you to change aspects of the plot. There are so many ways to customize the look of a plot that the number of optional arguments can be overwhelming at first. Let's start by looking at an example of a simple scatterplot showing ten data points: [1, 1], [2, 2] ... [10, 10].

\begin{footnotesize}
<<fig.width = 5, fig.height = 5, fig.align="center">>=
plot(x = 1:10,
     y = 1:10,
     main = "My First Plot",
     xlab = "This is the x-axis label",
     ylab = "This is the y-axis label",
     xlim = c(0, 11), # Min and max values for x-axis
     ylim = c(0, 11), # Min and max values for y-axis
     col = "blue", # Color of the points
     pch = 16, # Type of symbol (Filled circle)
     cex = 1, # Size of the symbols,
     type = "p" # Plot
     )
@
\end{footnotesize}


Aside from the x and y arguments, all of the arguments are optional. If you don't specify a specific argument, then R will use a default value, or try to come up with a value that makes sense. For example, if you don't specify the \texttt{xlim} and \texttt{ylim} arguments, R will set the limits so that all the points fit inside the plot.

\section{Symbol types: pch}

When you create a plot with \texttt{plot(x, y)}, you can specify the type of symbol with the \texttt{pch} argument. You can specify the symbol type in one of two ways: with an integer, or with a string. If you use a string (like \texttt{"p"}), R will use that text as the plotting symbol. If you use an integer value, you'll get the symbol that correspond to that number. See Figure~\ref{fig:pchplot} in the margin.

\begin{marginfigure}
\begin{tiny}
<<fig.width = 3, fig.height = 3>>=
par(mar  = rep(0, 4))

plot(x = rep(1:5, each = 5),
     y = rep(5:1, times = 5),
     pch = 1:25,
     xlab = "", ylab = "", xaxt = "n", yaxt = "n",
     xlim = c(.5, 5.5),
     ylim = c(0, 6),
     bty = "n", bg = "gray", cex = 1.4
     )

text(x = rep(1:5, each = 5) - .35,
     y = rep(5:1, times = 5),
     labels = 1:25, cex = 1.2
     )
@
\end{tiny}
\caption{The symbol types associated with the \texttt{pch} plotting parameter.}
\label{fig:pchplot}
\end{marginfigure}

Symbols differ in their border shape and how the filling is done. Symbols 1 through 14 only have borders and are always empty, while symbols 15 through 20 don't have a border and are always filled. Symbols 21 through 25 have both a border and a filling.

To specify the border color for all symbols, use the \texttt{col} argument. For symbols 21 through 25, you can additionally set the color of the fill using the \texttt{bg} ("background") argument.


\section{Other high-Level plotting commands}

While \texttt{plot()} is the most widely used high-level plotting command, there are several (perhaps even hundreds) of additional ones. I'll briefly highlight a few additional ones that you may wish to use

\subsection{Histograms \texttt{hist()}}

\begin{marginfigure}
<<fig.width = 4, fig.height = 4>>=
hist(x = ChickWeight$weight,
     main = "Chick Weights",
     xlab = "Weights (all time points"
     )
@
\caption{Histogram of weight data from \texttt{ChickWeight}}
\label{fig:histogram}
\end{marginfigure}

The function \texttt{hist()} is a high-level plotting command that creates (wait for it...) a histogram. Here are the main arguments for \texttt{hist()}:



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{hist()}\index{hist()}

\hline

\begin{description}

  \item[\tt{x}] \hfill \\
  A vector of data
    \item[\tt{breaks}] \hfill \\
 One of several values that defines how bins are created. The most common argument is a single number giving the number of bins you want in the histogram. See \texttt{?hist} for additional ways to specify this.
    \item[\tt{col}] \hfill \\
    The color of the filling of the bars. (e.g.; \texttt{col = "red"})
    \item[\tt{border}] \hfill \\
   The color of the border of the bars. (e.g.; \texttt{border = "green"})
    \item[\tt{probability}] \hfill \\
A logical value indicating whether to plot the results as probabilities (the default is FALSE)
\item[\tt{main, xlab, ylab, xlim, ylim ...}] \hfill \\
    Other standard plotting arguments

\end{description}

}
}
\vspace{5mm} %5mm vertical space


You can see an example of a histogram in the margin Figure~\ref{fig:histogram}.

\subsection{Boxplots \texttt{boxplot()}}

Boxplots aren't used so often anymore (for reasons that I'll show you shortly), but I think it's good to know how to make them, even if it's just for historical purposes. To create a boxplot, use the \texttt{boxplot()} function:


\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
boxplot(x = ChickWeight$weight, 
        names = "All Data", ylab = "Weight", 
        main = "Plot 1: All Weights")
@
\end{tiny}
\caption{Plotting data from a single vector}
\label{fig:boxplot1}
\end{marginfigure}

\begin{marginfigure}
\begin{tiny}
boxplot(weight ~ Diet, # Formula: DV is weight and IV is Diet
        data = ChickWeight, # dataframe
        xlab = "Diet", ylab = "Weight", 
        main = "Plot 2: Weight separated by Diet")
@
\end{tiny}
\caption{Plotting data as a function of levels of an independent variable using the \texttt{y {\raise.17ex\hbox{$\scriptstyle\sim$}} x} formula notation.}
\label{fig:boxplot2}
\end{marginfigure}



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{boxplot()}\index{boxplot()}

\hline

\begin{description}

  \item[\tt{formula, data}] \hfill \\
      A formula in the form \texttt{formula = dv {\raise.17ex\hbox{$\scriptstyle\sim$}} iv} indicating the dependent variable and independent variable, and a dataframe containing the variables in the formula. For example \texttt{formula = height {\raise.17ex\hbox{$\scriptstyle\sim$}} sex}
        \item[\tt{subset}] \hfill \\
  An optional logical vector indicating a subset of the data to plot. For example, the command \texttt{subset = gender == "male" \& weight < 120}, will only plot data for males with weight less than 120.
         \item[\tt{border, col}] \hfill \\
    The color of the borders (\texttt{border}) and filling (\texttt{col}) of the boxes.
        \item[\tt{names}] \hfill \\
      A string vector indicating the names of the boxes. E.g.; \texttt{names = c("males", "females")}
        \item[\tt{horizontal}] \hfill \\
   A logical value indicating whether to plot the boxes horizontally.
\end{description}

}
}
\vspace{5mm} %5mm vertical space



When you use \texttt{boxplot()}, you can either specify a single vector of data to plot, or you can use a \texttt{formula} to indicate a dependent and independent variable. If you do this, R will add separate boxes for all values of the independent variable.

Let's go through two examples of boxplots in Figure~\ref{fig:boxplot}. In the first plot, I just entered a single vector of data: \texttt{ChickWeight\$weight} representing all weight data in the dataframe. In the second plot, I plotted separate boxes for the different levels of \texttt{Diet} using the formula notation \texttt{weight {\raise.17ex\hbox{$\scriptstyle\sim$}} Diet}. If you're wondering how R knows that I'm referring to the \texttt{ChickWeight} dataframe when using the formula notation, the answer is that I had to specify the name of the dataframe \texttt{ChickWeight} as an additional \texttt{data} argument. This argument tells R that the objects in the formula are names in the \texttt{ChickWeight} dataframe.



\subsection{Beanplots: \texttt{beanplot()}}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4, echo = T>>=
require("beanplot")

bean.cols <- lapply(brewer.pal(4, "Set3"), 
                    function(x) {return(c(x, "black", "black", "black"))})

beanplot(weight ~ Diet, 
         data = ChickWeight,
         main = "Beans",
         xlab = "Diet",
         ylab = "Weight",
         col = bean.cols ,
         lwd = 1,
         what = c(1, 1, 1, 1), log = ""
         )
@
\end{tiny}
\caption{Beanplots from the \texttt{beanplot} package. Beanplots are great at simultaneously showing raw data, smoothed distributions, and group averages.}
\label{fig:beanplot}
\end{marginfigure}

The last high-level plotting I want to show you is the \texttt{beanplot()} function. This function creates a beanplot, which (like boxplots and histograms), shows you a distribution of sample data. However, as you can see in Figure~\ref{fig:beanplot}, they look much, much cooler than a boxplot or histogram. What's really great about beanplots is that they show you a combination of three elements: raw data, smoothed distribution lines, and group averages. This means that you can quickly detect outliers, multiple modes, or missing data much better than you can with boxplots.

To use the \texttt{beanplot()} function, you first need to download the \texttt{beanplot} package:

\begin{footnotesize}
<<eval = F>>=
install.packages("beanplot")
@
\end{footnotesize}

Here are some of the main arguments for \texttt{beanplot()}. Check out the help menu (\texttt{?beanplot}) to see several additional arguments


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{beanplot()}\index{beanplot()}

\hline

\begin{description}

  \item[\tt{formula, data}] \hfill \\
      A formula in the form \texttt{formula = dv {\raise.17ex\hbox{$\scriptstyle\sim$}} iv} indicating the dependent variable and independent variable, and a dataframe containing the variables in the formula. For example \texttt{formula = height {\raise.17ex\hbox{$\scriptstyle\sim$}} sex, data = survey}
        \item[\tt{subset}] \hfill \\
  An optional logical vector indicating a subset of the data to plot. For example, the command \texttt{subset = gender == "male" \& weight < 120}, will only plot data for males with weight less than 120.
         \item[\tt{what}] \hfill \\
A vector of four boolean (0 or 1) values indicating what to plot in the following order: the total average line, the beans, the bean average, and the beanlines. For example, to plot everything, use \texttt{what = c(1, 1, 1, 1)}. To plot just the beans, use \texttt{what = c(0, 0, 1, 0)}
        \item[\tt{color}] \hfill \\
    The colors in the plot. A vector of up to four colors can be used representing the areas of the beans, the lines inside the beans, the lines outside the beans, and the average line per bean. If you want to make each bean a different color, you have to specify a list of separate color vectors, one for each bean. Look at my code in Figure~\ref{fig:beanplot} for a way to do this using \texttt{lapply}.
        \item[\tt{names}] \hfill \\
A vector of names of the beans.
\item[\tt{overallline}] \hfill \\
A method for determining the overall line (either \texttt{"mean"}or \texttt{"median"})
\end{description}

}
}
\vspace{5mm} %5mm vertical space

The code for creating beanplots is very similar to the code for boxplots. The following code creates the plot in Figure~\ref{fig:beanplot}. 

\begin{footnotesize}
<<eval = F>>=
require("beanplot")
bean.cols <- lapply(brewer.pal(4, "Set3"), 
                    function(x) {return(c(x, "black", "black", "black"))})

beanplot(weight ~ Diet, 
         data = ChickWeight,
         main = "Beans",
         xlab = "Diet",
         ylab = "Weight",
         col = bean.cols ,
         lwd = 1,
         what = c(1, 1, 1, 1), log = ""
         )
@
\end{footnotesize}

One major new argument is \texttt{what}, which dictates what exactly is plotted. You specify \texttt{what} using a vector of four Boolean (0 or 1) values. In the plot in Figure~\ref{fig:beanplot}, I've set all values to 1 which means that the function will include all four plot elements. If you'd like to remove certain elements, like the individual lines or the average lines, you can remove them by replacing the respective 1s to 0s.





\section{Low-level plotting functions}

Once you've created a plot with a high-level plotting function, you can add additional elements, like additional data points, reference lines, text, and legends using low-level plotting functions. There are many low-level plotting functions, I will focus on those that I frequently use.

\subsection{Starting with a blank plot}


\begin{marginfigure}
\begin{tiny}
<<>>=
# Create a blank plot
plot(x = 1, y = 1, xlab = "", ylab = "", 
     xaxt = "n", yaxt = "n", type = "n", 
     xlim = c(0, 100), ylim = c(0, 100), main = "Blank Plot")
@
\end{tiny}
\caption{A blank plot. Useful to start with before adding elements with low-level plotting commands. Just make sure to set the axis limits to values that make sense for your future data.}
\label{fig:blankplot}
\end{marginfigure}

I like using low-level plotting functions so much that I frequently like to start with a (mostly) blank plotting space, and then add the main plot elements using low-level plotting functions. To start with a blank plot, use the \texttt{plot()} function combined with the arguments \texttt{type = "n", xaxt = "n", yaxt = "n"} and all labels set to \texttt{""}. See margin Figure~\ref{fig:blankplot} for an example

Once you've created a blank plot, you can proceed to add all the elements you'd like with low-level plotting commands. Let's start with \texttt{points()}, which adds points to an existing plot

\subsection{points()}


\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=

# Get subsets of data
diet.1 <- subset(ChickWeight, Diet == 1)
diet.2 <- subset(ChickWeight, Diet == 2)

# Create a blank plot
plot(x = 1, y = 1, xlab = "Time", ylab = "Weight", 
     type = "n", main = "Even More Chicken Weights", 
     xlim = c(0, 23), ylim = c(0, 315))

# Add red points for diet 1
points(diet.1$Time, diet.1$weight, pch = 16, col = "red")

# Add skyblue points for diet 2
points(diet.2$Time, diet.2$weight, pch = 16, col = "skyblue")
@
\caption{Adding additional points to an existing plot with points()}
\label{pointsexample}
\end{tiny}
\end{marginfigure}


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{points()}\index{points()}

\hline

\begin{description}

\item[\tt{x, y}] \hfill \\
Two vectors corresponding to the x and y values of the points

\item[\tt{pch, col, bg}] \hfill \\
Type of plotting symols (\texttt{pch}), color of the plotting symbols (\texttt{col}), and the color of the filling of the plotting symbols ((\texttt{bg})) for plotting symbols 21 through 25
  
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space


For example, to add red circle points to a plot where \texttt{x.vals} are the x-values and \texttt{y.vals} are the y.values, you can run the code:

<<eval = F>>=
points(x = x.vals, # x-values
       y = y.vals, # y-values
       col = "red", # Symbol color
       pch = 16 # Symbol type (circles)
       )
@

Because you can continue adding as many low-level plotting commands to a plot as you'd like, you can keep adding different types or colors of points by adding additional \texttt{points()} functions. However, keep in mind that because R plots each element on top of the previous one, early calls to \texttt{points()} might be covered by later calls. So add the points that you want in the foreground at the end!

In margin Figure~\ref{pointsexample}, I use the points function to plot data from ChickWeight, where chicks on diet 1 are plotted in red, and chicks on diet 2 are plotted in skyblue.

Next, we'll look at \texttt{abline()} which adds straight lines to a plot:


\subsection{abline()}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
par(mar = c(3, 0, 6, 0))
plot(1, xlim = c(0, 7), ylim = c(0, 1), 
     type = "n", xlab = "lty values", ylab = "",
     xaxt = "n", yaxt = "n", bty = "n", main = "")

abline(v = 1:6, lty = 1:6, lwd = 2)

mtext(1:6, 
      side = 3, 
      at = 1:6, cex = 1.5, line = 1
      )

mtext("lty = ...", side = 3, at = 3.5, line = 4, cex = 2)

@
\end{tiny}
\label{fig:ltytypes}
\caption{Line types generated from arguments to lty.}
\end{marginfigure}




\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{abline()}\index{abline()}

\hline

\begin{description}

\item[\tt{a, b}] \hfill \\
Numeric scalars or vectors indicating the slope (\texttt{a}) and intercept {\texttt{b}} of the line(s)

\item[\tt{h, v}] \hfill \\
Numeric scalars or vectors indicating the y-value of horizontal lines (\texttt{h}) or x-values of vertical lines {\texttt{v}}. For example, \texttt{abline(h = 1)} will add a horizontal line at y = 1, while \texttt{abline(v = 10)} will add a vertical line at x = 1

\item[\tt{lty, lwd}] \hfill \\
Type (\texttt{lty}) and width (\texttt{lwd}) of line. See margin Figure~\ref{fig:ltytypes} to see line types.
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space


For example, to add a vertical line at an x-value of 0 or a horizontal line at a y-vale at 100 you'd enter

<<eval = F>>=
abline(v = 0) # Add a vertical line at x = 0
abline(h = 100) # Add a horizontal line at y = 100
@

You can easily use abline() to add gridlines to plots by entering vectors in the \texttt{h} and \texttt{v} arguments. For example, to add gridlines to a plot at x-values and y-values from 0 to 10 in steps of 1, you'd enter

<<eval = F>>=
abline(v = 1:10) # Add vertical lines from 1 to 10
abline(h = 1:10) # Add horizontal lines from 1 to 10
@

In margin Figure~\ref{fig:gridlinesexample} I add gridlines and a diagonal reference line to a plot before adding points.

\begin{marginfigure}
\begin{tiny}
<<fig.width = 6, fig.height = 6>>=

# Create a blank plot
plot(x = 1, y = 1, xlab = "Group", ylab = "Length", 
     type = "n", main = "Gridlines with abline()", 
     xlim = c(0, 10), ylim = c(0, 10))

# Add horizontal gridlines
abline(h = 1:10, lwd = 1, col = gray(.8))

# Add vertical gridlines
abline(v = 1:10, col = gray(.8))

# Add main diagonal reference line
abline(a = 0, b = 1, lwd = 2, lty = 2)

# Create data
x.data <- rnorm(100, mean = 5, sd = 2)
y.data <- x.data + rnorm(100, mean = 0, sd = 3)

# Add points
points(x = x.data, 
       y = y.data, pch = 16, 
       col = gray(.4, alpha = .5), 
       cex = c(runif(90, 0, 2), runif(10, 3, 4))
       )
@
\caption{Adding gridlines to a plot with abline().}
\label{fig:gridlinesexample}
\end{tiny}
\end{marginfigure}

Next, we'll move on to \texttt{text}, which adds text to a plot

\subsection{text()}

With \texttt{text()}, you can add text to a plot. You can use text() to highlight specific points of interest in the plot, or to add information (like a third variable) for every point in a plot. Here are the main arguments to \texttt{text()}




\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{text()}\index{text()}

\hline

\begin{description}

\item[\tt{x, y}] \hfill \\
Numeric scalars or vectors specifying the coordinates of the \textt{labels}

\item[\tt{labels}] \hfill \\
String vector of the text you're plotting. Use the \textt{paste()} function to create multiple strings or combine strings with numeric objects.

\item[\tt{cex}] \hfill \\
Numeric scalar or vector specifying the size of the \texttt{labels}

\item[\tt{adj}] \hfill \\
A numerical value between 0 and 1 specifying the horizontal and/or vertical justification of text. Use 0 for left justification, .5 for centering, and 1 for right justification.

\item[\tt{pos}] \hfill \\
     Specifies the position of the text relative to the x-y coordinates. Values of 1, 2, 3 and 4 respectively indicate below, to the left, above, and to the right of the x-y coordinates.
     
\item[\tt{font}] \hfill \\  
 The font face. 1 = plain, 2 = bold, 3 = italic, 4 = bold-italic.  
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space


For example, if you want to add the text ``This is the center of the plot" to a plot at the coordinates (0, 0), you'd enter

<<eval = F>>=
text(x = 0, y = 0, labels = "This is the center of the plot")
@

Alternatively, let's say you have a scatterplot and wanted to add the x-values in text right above (pos = 3) each point, you could do this by using the code:

<<eval = F>>=
text(x = x.data, # X-values of data
     y = y,data, # X-values of data
     labels = x.data, # Add text of the x-values
     pos = 3 # Put the text right above the points
     )
@

To see \texttt{text()} in action, look at margin Figure \ref{fig:textexample} where I put the x-values of some random data right above their points:

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=

# Step 1: Generate Data

x.data <- rnorm(20, mean = 0, sd = 20)
y.data <- x.data + rnorm(20, mean = 0, sd = 20)

# Step 2:  Create a blank plot

plot(x = 1, xlab = "", ylab = "", 
     type = "n", main = "Adding text with text()", 
     xlim = c(-50, 50), ylim = c(-50, 50))

# Step 3: Add points

points(x = x.data, y = y.data, 
       pch = 16, col = gray(.5, alpha = .2))

# Step #4: Add x-coordinates in text above points
text(x = x.data,
     y = y.data,
     labels = round(x.data, 0),
     pos = 3, # put coordinates below the points
     cex = .7
     )

@
\end{tiny}
\caption{Adding text to a plot with text().}
\label{fig:textexample}
\end{marginfigure}

When entering text in the \texttt{labels} argument, keep in mind that R will, by default, plot the entire text in one line. However, if you are adding a long text string (like a sentence), you may want to separate the text into separate lines. To do this, add the text \texttt{"\textbackslash n"} where you want new lines to start. Look at Figure~\ref{fig:manylines} for an example.

\begin{marginfigure} To plot text on separate lines in a plot, put the tag \texttt{"\textbackslash n"} between lines.
\begin{tiny}
<<fig.width = 4.5, fig.height = 4.5>>=
plot(1, type = "n", main = "The \\n tag", 
     xlab = "", ylab = "")

# Text without \n breaks
text(x = 1, y = 1.3, labels = "Text without \\n", font = 2)
text(x = 1, y = 1.2,
     labels = "Haikus are easy. But sometimes they don't make sense. Refrigerator"
     )
abline(h = 1, lty = 2)
# Text with \n breaks
text(x = 1, y = .92, labels = "Text with \\n", font = 2)
text(x = 1, y = .7,
     labels = "Haikus are easy\nBut sometimes they don't make sense\nRefrigerator"
     )
@
\end{tiny}
\label{fig:manylines}
\caption{Using the \texttt{"\textbackslash n"} tag to plot text on separate lines.}
\end{marginfigure}


\subsection{Formatting text for plotting}

A common way to use text in a plot, either in the main title of a plot or using the \texttt{text()} function, is to combine text with numerical data. For example, you may want to include the text "Mean = 3.14" in a plot to show that the mean of the data is 3.14. But how can we combine numerical data with text? In R, we can do this with the \texttt{paste()} function:




\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{paste()}\index{paste()}

\hline

\begin{description}

\item[\tt{...}] \hfill \\
One or more scalars or vectors (numeric or string) to be combined. For example \texttt{paste("The mean of x is ", mean(x), sep = "")} will create a string combining text and a statistic calculated from data.

\item[\tt{sep}] \hfill \\
A character string that separates the arguments. Set to \texttt{""} for no separation

\end{description}

}
}
\vspace{5mm} %5mm vertical space



The paste function will be helpful to you anytime you want to combine either multiple strings, or text and strings together. For example, let's say you want to write text in a plot that says \texttt{The mean of these data are XXX}, where XXX is replaced by the group mean. To do this, just include the main text and the object referring to the numerical mean as arguments to \texttt{paste()}:\marginnote{When you include descriptive statistics in a plot, you will almost always want to use the \texttt{round(x, digits)} function to reduce the number of digits in the statistic.}

\begin{footnotesize}
<<>>=
data <- rnorm(200, mean = 20, sd = 10)
mean(data)
paste("The mean of the group is", mean(data)) # No rounding
paste("The mean of the group is", round(mean(data), 2)) # No rounding
@
\end{footnotesize}

\end{marginnote}

You can also use vectors as arguments to the \texttt{paste()} function. For example, let's say that you want to create a vector of labels for 5 groups, and you want each group to be labelled \texttt{"Group X"}. We can easily do this with \texttt{paste()}

\begin{footnotesize}
<<>>=
paste("Group", 1:5, sep = " ")
@
\end{footnotesize}


\subsection{curve()}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
plot(1, xlim = c(-5, 5), ylim = c(-5, 5), 
     type = "n", main = "Plotting function lines with curve()",
     ylab = "", xlab = "")
abline(h = 0)
abline(v = 0)

require("RColorBrewer")
col.vec <- brewer.pal(12, name = "Set3")[4:7]

curve(expr = x^2, from = -5, to = 5, 
      add = T, lwd = 2, col = col.vec[1])
curve(expr = x^.5, from = 0, to = 5, 
      add = T, lwd = 2, col = col.vec[2])
curve(expr = sin, from = -5, to = 5, 
      add = T, lwd = 2, col = col.vec[3])

my.fun <- function(x) {return(dnorm(x, mean = 2, sd = .2))}
curve(expr = my.fun, from = -5, to = 5, 
      add = T, lwd = 2, col = col.vec[4])

legend("bottomright", 
       legend = c("x^2", "x^.5", "sin(x)", "dnorm(x, 2, .2"),
       col = col.vec[1:4], lwd = 2,
       lty = 1, cex = .8, bty = "n"
       )
@
\end{tiny}
\caption{Using \texttt{curve()} to easily create lines of functions}
\label{fig:functionlines}
\end{marginfigure}


The \texttt{curve()} function allows you to add a line showing a specific function or equation to a plot


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{curve()}\index{curve()}

\hline

\begin{description}

\item[\tt{expr}] \hfill \\
 The name of a function written as a function of \texttt{x} that returns a single vector. You can either use base functions in R like \texttt{expr = $x^2$}, \texttt{expr = x + 4 - 2}, or use your own custom functions such as \texttt{expr = my.fun}, where \texttt{my.fun} is previously defined (e.g.; \texttt{my.fun <- function(x) {dnorm(x, mean = 10, sd = 3)}})

\item[\tt{from, to}] \hfill \\
 The starting (\texttt{from}) and ending (\texttt{to}) value of x to be plotted.

\item[\tt{add}] \hfill \\
 A logical value indicating whether or not to add the curve to an existing plot. If \texttt{add = FALSE}, then \texttt{curve()} will act like a high-level plotting function and create a new plot. If \texttt{add = TRUE}, then \texttt{curve()} will act like a low-level plotting function.

\item[\tt{lty, lwd, col}] \hfill \\
Additional arguments such as \texttt{lty}, \texttt{col}, \texttt{lwd}, ...

\end{description}

}
}
\vspace{5mm} %5mm vertical space

For example, to add the function $x^2$ to a plot from the x-values -10 to 10, you can run the code:

<<eval = F>>=
curve(expr = x^2, from = -10, to = 10)
@

If you want to add a custom function to a plot, you can define the function and then use that function name as the argument to \texttt{expr}. For example, to plot the normal distribution with a mean of 10 and standard deviation of 3, you can use this code:

<<eval = F>>=
my.fun <- function(x) {dnorm(x, mean = 10, sd = 3)}
curve(expr = my.fun, from = -10, to 10)
@


In Figure~\ref{fig:functionlines}, I use the \texttt{curve()} function to create curves of several mathematical formulas.


\subsection{legend()}


\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=

# Generate some random data
female.x <- rnorm(100)
female.y <- female.x + rnorm(100)
male.x <- rnorm(100)
male.y <- male.x + rnorm(100)

# Create plot with data from females
plot(female.x, female.y, pch = 16, col = 'blue',
     xlab = "x", ylab = "y", main = "Adding a legend with legend()"
     )

# Add data from males
points(male.x, male.y, pch = 16, col = 'orange')

# Add legend
legend("bottomright", 
       legend = c("Females", "Males"), 
       col = c('blue', 'orange'),
       pch = c(16, 16),
       bg = "white"
       )
@
\end{tiny}
\label{fig:legendexample}
\caption{Creating a legend labeling the symbol types from different groups}
\end{marginfigure}

The last low-level plotting function that we'll go over in detail is \texttt{legend()} which adds a legend to a plot. This function has the following arguments


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{legend()}\index{legend()}

\hline

\begin{description}

\item[\tt{x, y}] \hfill \\
Coordinates of the legend - for example, \texttt{x = 0, y = 0} will put the text at the coordinates (0, 0). Alternatively, you can enter a string indicating where to put the legend (i.e.; "topright", "topleft"). For example, \texttt{"bottomright"} will always put the legend at the bottom right corner of the plot.

\item[\tt{labels}] \hfill \\
  A string vector specifying the text in the legend. For example, \texttt{legend = c("Males, "Females")} will create two groups with names Males and Females.
  
\item[\tt{pch, lty, lwd, col, pt.bg, ...}] \hfill \\
Additional arguments specifying symbol types (\texttt{pch}), line types (\texttt{lty}), line widths (\texttt{lwd}), background color of symbol types 21 thorugh 25 ((\texttt{pt.bg})) and several other optional arguments. See \texttt{?legend} for a complete list


\end{description}

}
}
\vspace{5mm} %5mm vertical space


For example, to add a legend to to bottom-right of an existing graph where data from females are plotted in blue circles and data from males are plotted in pink circles, you'd use the following code:

<<eval = F>>=
legend("bottomright", # Put legend in bottom right of graph
       legend = c("Females", "Males"), # Names of groups
       col = c("blue", "orange"), # Colors of symbols
       pch = c(16, 16) # Point types
       )
@

In margin Figure~\ref{fig:legendexample} I use this code to add a legend to plot containing data from males and females.



\section{Additional low-level plotting functions}

There are many more low-level plotting functions that can add additional elements to your plots. Here are some I use. To see examples of how to use each one, check out their associated help menus.



\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
par(mar = c(0, 0, 3, 0))
    
plot(1, xlim = c(1, 100), ylim = c(1, 100), 
     type = "n", xaxt = "n", yaxt = "n", 
     ylab = "", xlab = "", main = "Adding simple figures to a plot")

text(25, 95, labels = "rect()")

rect(xleft = 10, ybottom = 70, 
     xright = 40, ytop = 90, lwd = 2, col = "coral")

text(25, 60, labels = "polygon()")

polygon(x = runif(6, 15, 35),
        y = runif(6, 40, 55),
        col = "skyblue"
        )


# polygon(x = c(15, 35, 25, 15),
#         y = c(40, 40, 55, 40),
#         col = "skyblue"
#         )

text(25, 30, labels = "segments()")

segments(x0 = runif(5, 10, 40),
         y0 = runif(5, 5, 25),
         x1 = runif(5, 10, 40),
         y1 = runif(5, 5, 25), lwd = 2
         )

text(75, 95, labels = "symbols(circles)")

symbols(x = runif(3, 60, 90),
        y = runif(3, 60, 70),
        circles = c(1, .1, .3),
        add = T, bg = gray(.5, .1))

text(75, 30, labels = "arrows()")

arrows(x0 = runif(3, 60, 90),
         y0 = runif(3, 10, 25),
         x1 = runif(3, 60, 90),
         y1 = runif(3, 10, 25), 
         length = .1, lwd = 2
         )
@
\end{tiny}
\end{marginfigure}


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{Additional low-level plotting functions}

\hline

\begin{description}

\item[\tt{rect()}] \hfill \\
    Add rectangles to a plot at coordinates specified by \texttt{xleft, ybottom, xright, ybottom}. For example, to add a rectangle with corners at (0, 0) and c(10, 10), specify \texttt{xleft = 0, ybottom = 0, xright = 10, ytop = 10}. Additional arguments like \texttt{col, border} change the color of the rectangle.

\item[\tt{polygon()}] \hfill \\
    Add a polygon to a plot at coordinates specified by vectors x and y. Additional arguments such as \texttt{col, border} change the color of the inside and border of the polygon

\item[\tt{segments(), arrows()}] \hfill \\
 Add segments (lines with fixed endings), or arrows to a plot.
 
\item[\tt{symbols(add = T)}] \hfill \\
Add symbols (circles, squares, rectangles, stars, thermometers) to a plot. The dimensions of each symbol are specified with specific input types. See \texttt{?symbols} for details. Specify \texttt{add = T} to add to an existing plot or \texttt{add = F} to create a new plot.
 
\item[\tt{axis()}] \hfill \\
 Add an additional axis to a plot (or add fully customizable  x and y axes). Usually you only use this if you set \texttt{xaxt = "n", yaxt = "n"} in the original high-level plotting function.
 
\item [\tt{mtext()}] \hfill \\
 Add text to the margins of a plot. Look at the help menu for \texttt{mtext()} to see parameters for this function.
\end{description}

}
}
\vspace{5mm} %5mm vertical space




\section{Saving plots to a file}

Once you've created a plot in R, you may wish to save it to a file so you can use it in another document. To do this, you'll use either the \texttt{pdf()} or \texttt{jpeg()} functions. These functions will save your plot to either a .pdf of jpeg file.


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{pdf() and jpeg()}

\hline

\begin{description}

\item[\tt{file}] \hfill \\
    The name and file destination of the final plot entered as a string. For example, to put a plot on my desktop, I'd write \texttt{file = "/Users/Nathaniel/Desktop/plot.pdf"} when creating a pdf, and \texttt{file = "/Users/Nathaniel/Desktop/plot.jpg"} when creating a jpeg.

\item[\tt{width, height}] \hfill \\
    The width and height of the final plot in inches.

\item[\tt{family()}] \hfill \\
An optional name of the font family to use for the plot. For example, \texttt{family = "Helvetica"} will use the Helvetica font for all text (assuming you have Helvetica on your system). For more help on using different fonts, look at section "Using extra fonts in R" in Chapter XX

\item[\tt{dev.off()}] \hfill \\
This is \textit{not} an argument to \texttt{pdf()} and \texttt{jpeg()}. You just need to execute this code after creating the plot to finish creating the image file (see examples below).
 
\end{description}

}
}
\vspace{5mm} %5mm vertical space

To use these functions to save files, you need to follow 3 steps

\begin{enumerate}
  \item Execute the \texttt{pdf()} or \texttt{jpeg()} functions with \texttt{file, width} and \textt{height} arguments.
  \item Execute all your plotting code.
  \item Complete the file by executing the command \texttt{dev.off()}. This tells R that you're done creating the file.
\end{enumerate}

Here's an example of the three steps.


<<eval = F>>=
# Step 1: Call the pdf command
pdf(file = "/Users/Nathaniel/Desktop/My Plot.pdf",   # The directory you want to save the file in
    width = 4, # The width of the plot in inches
    height = 4 # The height of the plot in inches
    )

# Step 2: Create the plot
plot(1:10, 1:10)
abline(v = 0) # Additional low-level plotting commands
text(x = 0, y = 1, labels = "Random text")

# Step 3: Run dev.off() to create the file!
dev.off()
@


You'll notice that after you close the plot with \texttt{dev.off()}, you'll see a message in the prompt like "null device".

Using the command  \texttt{pdf()} will save the file as a pdf. If you use  \texttt{jpeg()}, it will be saved as a jpeg.


\section{A worked example: Creating a plot with automated numeric labels}


Let's use the \texttt{paste()} command to create a histogram with labels indicating the mean, median, min, and mean of the dataset. We'll do this in 5 steps

1. Generate the data and the histogram\\
2. Add text and reference line for the mean\\
3. Add text and reference line for the minimum\\
4. Add text and reference line for the maximum\\
5. Add a subtitle in full sentences with each summary statistic.

\begin{footnotesize}
<<fig.width = 5, fig.height = 5>>=

# Step 1: Generate data and main histogram
data <- rnorm(100, mean = 20, sd = 2)

title.text <- paste(
  "Note: There were ", length(data), " data points. The mean and median of the data were ", 
  round(mean(data), 2), " and ", round(median(data, 2)), ".\nThe minimum and maximum values were ",
  round(min(data), 2), " and ", round(max(data), 2), ".", sep = "")


hist(data,
     xlim = c(10, 30),
     ylim = c(0, 40),
     main = title.text,
     cex.main = .7
     )

# Step 2: Add mean text and line
text(mean(data), 38, 
     labels = paste("Mean\n", round(mean(data), 2), sep = ""),
     adj = 0,
     pos = 4
)
abline(v = mean(data), lty = 2)

# Step 3: Add minimum text and line
text(min(data), 25, 
     labels = paste("Min\n", round(min(data), 2), sep = ""),
     adj = 0,
     pos = 2
)

abline(v = min(data), lty = 2)

# Step 4: Add maximum text and line
text(max(data), 25, 
     labels = paste("Max\n", round(min(data), 2), sep = ""),
     adj = 0,
     pos = 4
)

abline(v = max(data), lty = 2)
@
\end{footnotesize}

The benefit of using \texttt{paste()} over hard-coding the text (for example by typing \texttt{labels = "Mean = 20"}) is that the code will automatically change the value of the mean when the data changes. To see this in action, run the code above several times and see how the numbers automatically update. In later chapters, when use loops to create multiple graphs over different sets of data, this will become extremely helpful!


\section{Additional Tips}

\begin{itemize}
  
  \item Many high-level plotting functions can be used like low-level plotting functions if you add an additional argument like \texttt{new = F} or \texttt{add = T}. Look at the help menu for specific high-level functions to see which arguments allow you to add a high-level plot to an existing plot.
  

\end{itemize}





%----------------------------------------------------------------------------------------
%	CHAPTER 8
%----------------------------------------------------------------------------------------

\chapter{8: Customizing Plots}
\label{ch:8}

\begin{enumerate}

  \item Specifying and creating colors
  \item Specifying plot margins with \texttt{par(mar)}
  \item Putting several plots together with \texttt{par(mfrow)} and \texttt{layout}
  \item Using different fonts in plots

\end{enumerate}



\section{Colors in R}

There are many ways to specify colors in R. If you want to specify a color directly, you can do that in one of the following ways:

\subsection{Specifying colors as a string}
  
The easiest way to specify a color is to just write its name as a string. For example, you can write \texttt{"blue"}, \texttt{"lightgreen"}, \texttt{"red"}, among many other colors. To see a list of all the named colors, look at the vector \texttt{colors()} which contains all 657 named colors in R. Here is a random sample of 10 of them (to see all the colors, look at the color graph in the Appendix)
  
\begin{footnotesize}
<<>>=
colors()[sample(1:length(colors()), 10)]
@
\end{footnotesize}

\subsection{Shades of gray with \texttt{gray()}}
  
If you're a lonely, sexually repressed, 50+ year old housewife, then you might want to stick with shades of gray. If so, the function \texttt{gray(x)} is your answer. \texttt{gray()} is a function that takes a number (or vector of numbers) between 0 and 1 as an argument, and returns a shade of gray (or many shades of gray with a vector input). A value of 1 is equivalent to \texttt{"white"} while 0 is equivalent to \texttt{"black"}. This function is very helpful if you want to create shades of gray depending on the value of a numeric vector. For example, if you had survey data and plotted income on the x-axis and happiness on the y-axis of a scatterplot, you could determine the darkness of each point as a function of a third quantitative variable (such as number of children or amount of travel time to work). I plotted an example of this in Figure~\ref{fig:incomegray}.

\begin{marginfigure}

\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
inc <- rnorm(n = 200, mean = 50, sd = 10)
hap <- inc + rnorm(n = 200, mean = 0, sd = 15)
drive <- inc + rnorm(n = 200, mean = 0, sd = 5)

plot(x = inc, y = hap, pch = 16, 
     col = gray((drive - min(drive)) / max(drive - min(drive)), alpha = .4),
     cex = 1.5,
     xlab = "income", ylab = "happiness"
     )

@
\end{tiny}
\caption{Using the \texttt{gray()} function to easily create shades of gray in plotting symbols based on numerical data.}
\label{fig:incomegray}
\end{marginfigure}

\subsection{RGB values: \texttt{rgb()}}

Every color can be defined by its RGB ("Red", "Green", "Blue") value. This value specifies the combination of shades of Red, Green and Blue that create that color. Traditionally, each color shade is defined on a scale from 0 to 255. For example, the RGB value [255, 0, 0] is pure Red, while [0, 255, 0] is pure Green.

To create a color from RGB values, use the function \texttt{rgb()}


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{rgb()}\index{rgb()}

\hline

\begin{description}

\item[\tt{red, green blue}] \hfill \\
Numeric arguments indicating the strength of red, green, and blue heus

\item[\tt{maxColorValue}] \hfill \\
A number indicating the maximum possible hue value. The default is 1 - however, most people use \texttt{maxColorValue = 255}
  
\item[\tt{alpha}] \hfill \\
The opacity of the color(s) inputted as a number between 0 and \texttt{maxColorValue}


\end{description}

}
}
\vspace{5mm} %5mm vertical space



When you use the function \texttt{rgb()}, the function will return a string as output. The string will look like nonsense to you, but that's just how R names colors:

\begin{footnotesize}
<<>>=
rgb(red = 0, green = 255, blue = 0, maxColorValue = 255) # pure red
rgb(red = 0, green = 255, blue = 0, alpha = 100, maxColorValue = 255) # transparent red
rgb(red = 100, green = 100, blue = 100, maxColorValue = 255) # even mixture
@
\end{footnotesize}

Now, if you're not used to interpreting colors as RGB values, you may gloss over this section and think you'll never use it. However, look at this chapter's \textit{Additional Tips} for a really cool method of 'stealing' the exact color from \textit{anything} on your computer screen and using \texttt{rgb()} to then use that color in your R plots!

\subsection{Color Palettes with the \texttt{RColorBrewer} package}

If you use many colors in the same plot, it's probably a good idea to choose colors that compliment each other. An easy way to select colors that go well together is to use a \textit{color palette} - a collection of colors known to go well together.

One package that is great for getting (and even creating) palettes is \texttt{RColorBrewer}. Here are some of the palettes in the package. The name of each palette is in the first column, and the colors in each palette are in each row:


<<fig.width = 8>>=
require("RColorBrewer")
display.brewer.all()
@


To use one of the palettes, execute the function \texttt{brewer.pal(n, name)}, where \texttt{n} is the number of colors you want, and \texttt{name} is the name of the palette. For example, to get 4 colors from the color set ``Set1", you'd use the code

\begin{footnotesize}
<<>>=
my.colors <- brewer.pal(4, "Set1") # 4 colors from Set1
my.colors
@
\end{footnotesize}

I know the results look like gibberish, but trust me, R will interpret them as the colors in the palette. Once you store the output of the \texttt{brewer.pal()} function as a vector (something like \texttt{my.colors}), you can then use this vector as an argument for the colors in your plot.

\subsection{Numerically defined color gradients with \texttt{colorRamp2}}

My favorite way to generate colors that represent numerical data is with the function \texttt{colorRamp2} in the \texttt{circlize} package (the same package that creates that really cool \texttt{chordDiagram} from Chapter 1). The \texttt{colorRamp2} function allows you to easily generate shades of colors based on numerical data. 

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 6>>=
require("RColorBrewer")
require("circlize")

# Create Data
drinks <- sample(1:30, size = 100, replace = T)
smokes <- sample(1:30, size = 100, replace = T)
risk <- 1 / (1 + exp(-drinks / 20 + rnorm(100, mean = 0, sd = 1)))

# Create color function from colorRamp2
smoking.colors <- colorRamp2(breaks = c(0, 15, 30),
                  colors = c("blue", "orange", "red"),
                  transparency = .3
                  )

# Set up plot layout
layout(mat = matrix(c(1, 2), nrow = 2, ncol = 1), 
       heights = c(2.5, 5), widths = 4)

# Top Plot
par(mar = c(4, 4, 2, 1))
plot(1, xlim = c(-.5, 31.5), ylim = c(0, .3), 
     type = "n", xlab = "Cigarette Packs", 
     yaxt = "n", ylab = "", bty = "n", 
     main = "colorRamp2 Example")

segments(x0 = c(0, 15, 30), 
         y0 = rep(0, 3), 
         x1 = c(0, 15, 30),
         y1 = rep(.1, 3), 
         lty = 2)

points(x = 0:30, 
       y = rep(.1, 31), pch = 16, 
       col = smoking.colors(0:30))

text(x = c(0, 15, 30), y = rep(.2, 3), 
     labels = c("Blue", "Orange", "Red"))

# Bottom Plot
par(mar = c(4, 4, 5, 1))
plot(x = drinks, y = risk, col = smoking.colors(smokes), 
     pch = 16, cex = 1.2, main = "Plot of (Made-up) Data", 
     xlab = "Drinks", ylab = "Risk")

mtext(text = "Point color indicates smoking rate", line = .5, side = 3)
@
\end{tiny}
\label{fig:colorramp}
\end{marginfigure}


The best way to explain how \texttt{colorRamp2} works is by giving you an example. Let's say that you want to want to plot data showing the relationship between the number of drinks someone has on average per week and the resulting risk of some adverse health effect. Further, let's say you want to color the points as a function of the number of packs of cigarettes per week that person smokes, where a value of 0 packs is colored Blue, 10 packs is Orange, and 30 packs is Red. Moreover, you want the values in between these \textit{break points} of 0, 10 and 30 to be a mix of the colors. For example, the value of 5 (half way between 0 and 10) should be an equal mix of Blue and Orange.

\texttt{colorRamp2} allows you to do exactly this. The function has three arguments:

\begin{itemize}
  \item \texttt{breaks}: A vector indicating the break points
  \item \texttt{colors}: A vector of colors corresponding to each value in \texttt{breaks}
  \item \texttt{transparency}: A value between 0 and 1 indicating the transparency (1 means fully transparent)
\end{itemize}

When you run the function, the function will actually \textit{return} another function that you can then use to generate colors. Once you store the resulting function as an object (something like \texttt{my.color.fun} You can then apply this new function on numerical data (in our example, the number of cigarettes someone smokes) to obtain the correct color for each data point. 

For example, let's create the color ramp function for our smoking data points. I'll use \texttt{colorRamp2} to create a function that I'll call \texttt{smoking.colors} which takes a number as an argument, and returns the corresponding color:

<<>>=
smoking.colors <- colorRamp2(breaks = c(0, 15, 30),
                  colors = c("blue", "orange", "red"),
                  transparency = .3
                  )

smoking.colors(0) # Equivalent to blue
smoking.colors(20) # Mix of orange and red
@

To see this function in action, check out the the margin Figure~\ref{fig:colorramp} for an example, and check out the help menu \texttt{?colorRamp2} for more information and examples.

\subsection{Stealing any color from your screen with a kuler}

One of my favorite tricks for getting great colors in R is to use a \textit{color kuler}. A color kuler is a tool that allows you to determine the exact RGB values for a color on a screen. For example, let's say that you wanted to use the exact colors used in the Google logo. To do this, you need to use an app that allows you to pick colors off your computer screen. On a Mac, you can use the program called "Digital Color Meter." If you then move your mouse over the color you want, the software will tell you the exact RGB values of that color. In the image below, you can see me figuring out that the RGB value of the G in Google is R: 19, G: 72, B: 206. Using this method, I figured out the four colors of Google! Check out the margin Figure~\ref{fig:googlecolors} for the grand result.

\begin{marginfigure}
\begin{tiny}
<<fig.width = 3, fig.height = 3>>=
google.colors <- c(
  rgb(19, 72, 206, maxColorValue = 255),
  rgb(206, 45, 35, maxColorValue = 255),
  rgb(253, 172, 10, maxColorValue = 255),
  rgb(18, 140, 70, maxColorValue = 255))
                   
par(mar = rep(0, 4))

plot(1, xlim = c(0, 7), ylim = c(0, 1), 
     xlab = "", ylab = "", xaxt = "n", yaxt = "n",
     type = "n", bty = "n"
     )

points(1:6, rep(.5, 6),
       pch = c(15, 16, 16, 17, 18, 15), 
       col = google.colors[c(1, 2, 3, 1, 4, 2)],
       cex = 2.5)

text(3.5, .7, "Look familiar?", cex = 1.5)
@
\end{tiny}
\label{fig:googlecolors}
\caption{Stealing colors from the internet. Not illegal (yet).}
\end{marginfigure}

\begin{figure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/kuler.png}
\end{figure}


\pagebreak

\section{Plot margins}

\begin{marginfigure}
\begin{tiny}
<<>>=
par(mar = rep(8, 4))

x.vals <- rnorm(500)
y.vals <- x.vals + rnorm(500, sd = .5)

plot(x.vals, y.vals, xlim = c(-2, 2), ylim = c(-2, 2),
     main = "", xlab = "", ylab = "", xaxt = "n", 
     yaxt = "n", bty = "n", pch = 16, col = gray(.5, alpha = .2))

axis(1, at = seq(-2, 2, .5), col.axis = gray(.8), col = gray(.8))
axis(2, at = seq(-2, 2, .5), col.axis = gray(.8), col = gray(.8))

par(new = T)
par(mar = rep(0, 4))
plot(1, xlim = c(0, 1), ylim = c(0, 1), type ="n", 
     main = "", bty = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n")

rect(0, 0, 1, 1)

rect(.21, .22, .85, .8, lty = 2)

arrows(c(.5, .5, 0, .85), 
       c(.8, .22, .5, .5), 
       c(.5, .5, .21, 1),
       c(1, 0, .5, .5), 
       code = 3, length = .1
       )

text(c(.5, .5, .09, .93), 
     c(.88, .11, .5, .5), 
     labels = c("mar[1]", "mar[2]", "mar[3]", "mar[4]"),
     pos = c(2, 2, 1, 1)
     )

text(.7, .9, "This is Margin Text\nMade with mtext()")





@
\end{tiny}
\label{fig:marplot}
\end{marginfigure}


All plots in R have margins surrounding them that separate the main plotting space from the area where the axes, labels and additional text lie.. To visualize how R creates plot margins, look at margin Figure~\ref{fig:marplot}.

You can adjust the size of the margins by specifying a margin parameter using the syntax \texttt{par(mar = c(a, b, c, d))} before you execute your first high-level plotting function, where a, b, c and d are the size of the margins on the bottom, left, top, and right of the plot. Let's see how this works by creating two plots with different margins:

In the plot on the left, I'll set the margins to 3 on all sides. In the plot on the right, I'll set the margins to 6 on all sides.

\begin{footnotesize}
<<fig.width = 8, fig.height = 4>>=
par(mfrow = c(1, 2)) # Put plots next to each other

# First Plot
par(mar = rep(2, 4)) # Set the margin on all sides to 2
plot(1:10)
mtext("Small Margins", side = 3, line = 1, cex = 1.2)

# Second Plot
par(mar = rep(6, 4)) # Set the margin on all sides to 6
plot(1:10)
mtext("Large Margins", side = 3, line = 1, cex = 1.2)
@
\end{footnotesize}

\marginnote{The default value for \texttt{mar} is \texttt{c(5.1, 4.1, 4.1, 2.1)}}

You'll notice that the margins are so small in the first plot that you can't even see the axis labels, while in the second plot there is plenty (probably too much) white space around the plotting region.

In addition to using the \texttt{mar} parameter, you can also specify margin sizes with the \text{mai} parameter. This acts just like \texttt{mar} except that the values for \texttt{mai} set the margin size in inches.


\pagebreak

\section{Arranging multiple plots with \texttt{par(mfrow)} and \texttt{layout}}

R makes it easy to arrange multiple plots in the same plotting space. The most common ways to do this is with the \texttt{par(mfrow)} parameter, and the \texttt{layout()} function. Let's go over each in turn:

\subsection{Simple plot layouts with par(mfrow) and par(mfcol)}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 6, fig.height = 6>>=
par(mfrow = c(3, 3))
par(mar = rep(2.5, 4))

for(i in 1:9) { # Loop across plots

# Generate data  
x <- rnorm(100)
y <- x + rnorm(100)

# Plot data
  plot(x, y, xlim = c(-2, 2), ylim = c(-2, 2),
       col.main = "gray",
       pch = 16, col = gray(.0, alpha = .1),
       xaxt = "n", yaxt = "n"
       )

# Add a regression line for fun
abline(lm(y ~ x), col = "gray", lty = 2)


# Add gray axes
axis(1, col.axis = "gray", 
     col.lab = gray(.1), col = "gray")

axis(2, col.axis = "gray", 
     col.lab = gray(.1), col = "gray")

# Add large index text
text(0, 0, i, cex = 7)

# Create box around border
box(which = "figure", lty = 2)

}
@
\end{tiny}
\caption{A matrix of plotting regions created by \texttt{par(mfrow = c(3, 3))}}
\label{fig:mfrow}
\end{marginfigure}


The \texttt{mfrow} and \texttt{mfcol} parameters allow you to create a matrix of plots in one plotting space. Both parameters take a vector of length two as an argument, corresponding to the number of rows and columns in the resulting plotting matrix. For example, the following code sets up a 3 x 3 plotting matrix.

<<eval = F>>=
par(mfrow = c(3, 3)) # Create a 3 x 3 plotting matrix
@

When you execute this code, you won't see anything happen. However, when you execute your first high-level plotting command, you'll see that the plot will show up in the space reserved for the first plot (the top left). When you execute a second high-level plotting command, R will place that plot in the second place in the plotting matrix - either the top middle (if using \texttt{par(mfrow)} or the left middle (if using \texttt{par(mfcol)}). As you continue to add high-level plots, R will continue to fill the plotting matrix.

So what's the difference between \texttt{par(mfrow)} and \texttt{par(mfcol)}? The only difference is that while \texttt{par(mfrow)} puts sequential plots into the plotting matrix by row, \texttt{par(mfcol)} will fill them by column.

When you are finished using a plotting matrix, be sure to reset the plotting parameter back to its default state:

<<eval = F>>=
par(mfrow = c(1, 1))
@

If you don't reset the \texttt{mfrow} parameter, R will continue creating new plotting matrices.

\subsection{Complex plot layouts with \texttt{layout()}}

While \texttt{par(mfrow)} allows you to create matrices of plots, it does not allow you to create plots of different sizes. In order to arrange plots in different sized plotting spaces, you need to use the \texttt{layout()} function. Unlike \texttt{par(mfrow)}, \texttt{layout} is not a plotting parameter, rather it is a function all on its own. Let's go through the main arguments of \texttt{layout()}:

\newfun{layout(mat, widths, heights)}

\begin{itemize}

  \item \texttt{mat}: A matrix indicating the location of the next N figures in the global plotting space. Each value in the matrix must be 0 or a positive integer. R will plot the first plot in the entries of the matrix with 1, the second plot in the entries with 2,...
  \item \texttt{widths}: A vector of values for the widths of the columns of the plotting space.
  \item \texttt{heights}: A vector of values for the heights of the rows of the plotting space.

\end{itemize}

The \texttt{layout()} function can be a bit confusing at first, so I think it's best to start with an example. Let's say you want to place histograms next to a scatterplot: Let's do this using layout

\begin{marginfigure}
\begin{tiny}
<<fig.width = 2, fig.height = 2>>=
layout.matrix <- matrix(c(2, 1, 0, 3), nrow = 2, ncol = 2)

layout(mat = layout.matrix, 
       heights = c(1, 2), # Heights of the two rows
       widths = c(2, 2) # Widths of the two columns
       )

layout.show(3)
@
\end{tiny}
\caption{A plotting layout created by setting a layout matrix and specific heights and widths.}
\label{fig:layout}
\end{marginfigure}

We'll begin by creating the \textit{layout matrix}, this matrix will tell R in which order to create the plots:

<<>>=
layout.matrix <- matrix(c(0, 2, 3, 1), nrow = 2, ncol = 2)
layout.matrix
@

Looking at the values of \texttt{layout.matrix}, you can see that we've told R to put the first plot in the bottom right, the second plot on the bottom left, and the third plot in the top right. Because we put a 0 in the first element, R knows that we don't plan to put anything in the top left area.

Now, because our layout matrix has two rows and two columns, we need to set the widths and heights of the two columns. We do this using a numeric vector of length 2. I'll set the heights of the two rows to 1 and 2 respectively, and the widths of the columns to 1 and 2 respectively. Now, when I run the code \texttt{layout.show(3)}, R will show us the plotting region we set up (see margin Figure~\ref{fig:layout})

Now we're ready to put the plots together

\begin{footnotesize}
<<fig.width = 6, fig.height = 6>>=

layout.matrix <- matrix(c(2, 1, 0, 3), nrow = 2, ncol = 2)

layout(mat = layout.matrix, 
       heights = c(1, 2), # Heights of the two rows
       widths = c(2, 1) # Widths of the two columns
       )

x.vals <- rnorm(100, mean = 100, sd = 10)
y.vals <- x.vals + rnorm(100, mean = 0, sd = 10)

# Plot 1: Scatterplot
par(mar = c(5, 4, 0, 0))
plot(x.vals, y.vals)
abline(h = median(y.vals), lty = 1, col = "gray")
abline(v = median(x.vals), lty = 1, col = "gray")


# Plot 2: X boxplot
par(mar = c(0, 4, 0, 0))
boxplot(x.vals, xaxt = "n", 
        yaxt = "n", bty = "n", yaxt = "n", 
        col = "white", frame = F, horizontal = T)

# Plot 3: Y boxplot
par(mar = c(5, 0, 0, 0))
boxplot(y.vals, xaxt = "n", 
        yaxt = "n", bty = "n", yaxt = "n", 
        col = "white", frame = F)


@
\end{footnotesize}


\section{Using alternative fonts in pdfs with the extrafont package}

If you don't like the default font that R uses in creating plots, you can use the \texttt{extrafont} package to use additional fonts in plots saved as .pdf files. However, let me warn you that it's not as easy as just selecting a font from a drop-down menu (like in Word). To use other fonts, follow these four steps:

First, install and load the \texttt{extrafont} package

<<eval = F>>=
install.packages("extrafont")
library("extrafont")
@

<<eval = T, echo = F>>=
library("extrafont")
@


Second, import the fonts on your computer into R by running the \texttt{font\_import()} function. When you execute this, you'll receive a warning telling you that importing the fonts may take a few minutes. Type "y" and watch R do it's magic. Don't worry if you see some warnings or if it takes a few minutes,once you've run \texttt{font\_import()} once you \textit{won't} need to run it again on your machine.

<<eval = F>>=
font_import()
@

Third,load your fonts into your current R session using the function \texttt{loadfonts()}. Unfortunately, you DO need to run this in each R session.

<<eval = F>>=
loadfonts()
@


Now you're ready to go. To see which fonts are available to use in your plots, use the \texttt{fonts()} function. When you execute this function, you'll see a table with all the fonts you can use. Let's do this on my system (I'll just print the first 50 values here)

\begin{tiny}
<<eval = T>>=
fonts()[1:50] # Show me the first 50 fonts on my system
@
\end{tiny}

You will likely have more or less fonts than I have on my system - if you want more fonts, you'll need to download them. Now that we have a list of fonts we can use, we can finally create a plot using the new font. To do this, we need to add two special arguments when creating our plot:

\begin{enumerate}
\item In the \texttt{pdf()} function, add the argument \texttt{family = "fontname"}, where \texttt{fontname} is the name of the font you want to use.
\item After executing \texttt{dev.off()} to finish the plot, execute the command \texttt{embed\_fonts("filename.pdf")}. This command will embed the font in the pdf file.
\end{enumerate}

Let's follow these steps to create a plot using the Helvetica Light font. Again, I found this font on my computer by running \texttt{fonts()}. If you don't have this font on your computer, then it won't work for you. Instead, replace the argument \texttt{"HelvLight"} with a different font on your system:


<<warning = F>>=
pdf("/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/helveticalight.pdf",
    width = 4, height = 4, 
    family = "HelvLight" # Specify the font in the plot
    )

hist(x = rnorm(100), # some random data
     col = "skyblue", 
     main = "Helvetica Light font")

dev.off()

embed_fonts("/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/helveticalight.pdf") # Embed the fonts in the pdf
@

Look at Figure X to see the plot that this code created

\begin{marginfigure}
\includegraphics[]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/helveticalight.pdf}
\caption{Plot created with Helvetica Light font (see the main text for plotting code).}
\label{fig:helvetica}
\end{marginfigure}


\pagebreak
\section{Additional Tips}

\begin{itemize}


  \item To change the background color of a plot, add the command \texttt{par(bg = mycolor)} (where \textt{my.color} is the color you want to use) prior to creating the plot. For example, the following code will put a light gray background behind a histogram:
  
<<fig.width = 3, fig.height = 3>>=
par(bg = gray(.9))
hist(x = rnorm(100))
@

See Figure~\ref{fig:coloredbackground} for a nicer example.

\begin{marginfigure}
\begin{tiny}
<<>>=
pdf("/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/parrothelvetica.pdf", 
    width = 8, height = 6, family = "HelvLight")

parrot.data <- data.frame(
  "parrots" = 0:6,
  "female" = c(200, 150, 100, 175, 55, 25, 10),
  "male" = c(150, 125, 180, 242, 10, 62, 5)
  )

n.data <- nrow(parrot.data)

par(bg = rgb(61, 55, 72, maxColorValue = 255),
    mar = c(8, 6, 6, 3)
    )

plot(1, xlab = "", ylab = "", xaxt = "n",
     yaxt = "n", main = "", bty = "n", type = "n",
     ylim = c(0, 250), xlim = c(.5, n.data + .5)
     )

abline(h = seq(0, 250, 50), lty = 3, col = gray(.95), lwd = 1)

mtext(text = seq(50, 250, 50), 
      side = 2, at = seq(50, 250, 50), 
      las = 1, line = 1, col = gray(.95))

mtext(text = paste(0:(n.data - 1), " Parrots"), 
      side = 1, at = 1:n.data, las = 1, 
      line = 1, col = gray(.95))


female.col <- gray(1, alpha = .7)
male.col <- rgb (226, 89, 92, maxColorValue = 255, alpha = 220)

rect.width <- .35
rect.space <- .04

rect(1:n.data - rect.width - rect.space / 2,
     rep(0, n.data),
     1:n.data - rect.space / 2,
     parrot.data$female,
     col = female.col, border = NA
     )

rect(1:n.data + rect.space / 2,
     rep(0, n.data),
     1:n.data + rect.width + rect.space / 2,
     parrot.data$male,
     col = male.col, border = NA
     )

legend(n.data - 1, 250, c("Male Pirates", "Female Pirates"), 
       col = c(female.col, male.col), pch = rep(15, 2),
       bty = "n", pt.cex = 1.5, text.col = "white"
       )

mtext("Number of parrots owned by pirates", side = 3, 
      at = n.data + .5, adj = 1, cex = 1.2, col = "white")

mtext("Source: Drunken survey on 22 May 2015", side = 1, 
      at = 0, adj = 0, line = 3, font = 3, col = "white")

dev.off()

embed_fonts("/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/parrothelvetica.pdf") # Embed the fonts in the pdf
@
\end{tiny}
\includegraphics[]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/parrothelvetica.pdf}
\caption{Use \texttt{par(bg = my.color)} before creating a plot to add a colored background. The design of this plot was inspired by \texttt{http://www.vox.com/2015/5/20/8625785/expensive-wine-taste-cheap}.}
\label{fig:coloredbackground}
\end{marginfigure}


\item Sometimes you'll mess so much with plotting parameters that you may want to set things back to their default value. To see the default values for all the plotting parameters, execute the code \texttt{par()} to print the default parameter values for all plotting parameters to the console.



\end{itemize}


%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{9: Advanced dataframe manipulation}
\label{ch:9}


Chapter Goals

\begin{enumerate}
  \item Grouped aggregation with aggregate() and dplyr
  \item Merging datasets with merge()
  \item Common data management tasks: rescaling, recoding
\end{enumerate}


In this chapter, we'll cover how to do advanced dataframe manipulation. You'll learn how to recode values of a dataframe and quickly and easily calculate summary data from a dataframe, 


\section{Recoding values in a vector}

%' 
%' 
%' \begin{marginfigure}
%' \begin{tiny}
%' <<>>=
%' # Create blank plot with no margins
%' par(mar = rep(0, 4))
%' plot(1, xlim = c(0, 1), ylim = c(0, 13), 
%'      bty = "n", xlab = "", ylab = "", main = "",
%'      type = "n", xaxt = "n", yaxt = "n")
%' 
%' data.vec <- c(-3, 0, 5)
%' 
%' # Original
%' text(.5, 12.5, "Original", cex = 2)
%' 
%' text(rep(.5, 3), 9:11, data.vec)
%' rect(.45, 8.5, .55, 11.5)
%' 
%' # Step 1
%' left <- .2
%' 
%' text(left, 7.5, "Step 1 - Copy", cex = 1.5)
%' text(left, 6.5, "new <- old", cex = 1)
%' 
%' 
%' text(rep(left, 3), 3:5, data.vec)
%' rect(left - .05, 2.5, left + .05, 5.5)
%' 
%' # Step 2
%' mid <- .5
%' 
%' text(mid, 7.5, "Step 2 - Index", cex = 1.5)
%' text(mid, 6.5, "log.vec <- condition", cex = 1)
%' 
%' 
%' text(rep(mid - .1, 3), 3:5, data.vec)
%' rect(mid - .15, 2.5, mid - .05, 5.5)
%' 
%' text(rep(mid - .03, 3), 3:5, rep("< 0", 3))
%' 
%' text(rep(mid + .05, 3), 3:5, data.vec < 0)
%' rect(mid, 2.5, mid + .1, 5.5)
%' 
%' # Step 3
%' right <- .75
%' 
%' text(right, 7.5, "Step 3 - Assign", cex = 1.5)
%' text(right, 6.5, "new[log.vec] <- value", cex = 1)
%' 
%' 
%' @
%' \end{tiny}
%' \label{fig:recoding}
%' \caption{A visual representation of how indexing with logical vectors works in R. When you apply a logical vector (a vector containing only TRUE and FALSE values) to a data vector, R will return the the values in the data vector where the logical vector is TRUE.}
%' \end{marginfigure}
%' @


Let's say that you conducted an online survey where you asked 100 people some basic demographic information and then asked them how happy they are with their life on a scale from 1 to 8. When you look at the dataset, you realize that many people gave invalid answers to the questions. For example, some people said they had a negative income and had a negative number of siblings. How can you fix these data? In this chapter, we'll cover the basics of data-recoding

There are three basic steps to recoding values in a vector:

\marginnote{

\textbf{3 Steps to recoding values}

\begin{enumerate}
\item Copy the original column (\texttt{original}) to a new column with a new name (\texttt{new}) using assignment.
\item Create a logical vector indicating which values of \texttt{new} should be converted.
\item Index \texttt{new} by the logical vector and assign the updated value to it.
\end{enumerate}

}

\subsection{3 Steps to recoding values}

\begin{enumerate}

\item Copy the original column (\texttt{original}) to a new column with a new name (\texttt{new}) using assignment.
\item Create a logical vector indicating which values of \texttt{new} should be converted.
\item Index \texttt{new} by the logical vector and assign the updated value to it.

\end{enumerate}

Let's start with a dummy example where we take the integers from 1 to 10, then convert all values greater than 5 to 999

<<>>=
original <- 1:10

new.vec <- original # Step 1
log.vec <- new.vec > 5 # Step 2
new.vec[log.vec] <- 999 # Step 3

new.vec
@

As you can see, our new vector \texttt{new.vec} is identical to the integers 1 to 10 up until the value of 6, where all values have been converted to 999.

\subsection{Recoding values from the pirate survey}
 
Let's start by using the dataset \texttt{pirate\_survey\_werrors.txt} which is stored at http://nathanieldphillips.com/wp-content/uploads/2015/05/pirate\_survey\_werrors.txt. This is a tab-delimited file containing results from 1,000 pirates.

To load the data, execute the following commands:

<<>>=
pirates.errors <- read.table("http://nathanieldphillips.com/wp-content/uploads/2015/05/pirate_survey_werrors.txt", sep = "\t", stringsAsFactors = F)
@


Unfortunately, some pirates decided to supply some invalid answers. We'll start with the \texttt{sex} variable. To see the values that are currently in this column, we'll run \texttt{table()}:

<<>>=
table(pirates.errors$sex)
@

Very funny guys. There should only be three valid responses to this question: female, male, and other/NA. Let's recode all the other values to NA. We'll do this in three steps:

\begin{enumerate}

  \item Copy the values of \texttt{sex} into a new vector called \texttt{sex.r} standing for "sex recoded"
  \item Create a logical vector called \texttt{log.vec} that indicates which values of sex.r are valid - that is, in the set of values \texttt{c("female", "male", "other/NA")}
  \item Assign a value of \texttt{NA} to all values of \texttt{sex.r} for which \texttt{log.vec} is FALSE.
  
\end{enumerate}



<<>>=
# Step 1: Copy sex to a new column called sex.r 
pirates.errors$sex.r <- pirates.errors$sex

# Step 2: Create a logical vector indicating which values are valid
log.vec <- pirates.errors$sex.r %in% c("female", "male", "other/NA")

# Step 3: Recode all invalid values to NA
pirates.errors$sex.r[log.vec == FALSE] <- NA # Step 3
@


Let's make sure this worked by looking at the values of \texttt{sex.r}. Hopefully, we will only see valid entries now:

\begin{footnotesize}
<<>>=
table(pirates.errors$sex.r, useNA = "ifany")
@
\end{footnotesize}

As you can see, our new column \texttt{sex.r} only contains valid entries, so it looks like our recoding did what we wanted. \marginnote{Note that the \texttt{table()} function does not (by default), show NA values. To see how many NA values are in the dataset, you can include the argument \texttt{useNA = "ifany"} as in \texttt{table(pirates.errors\$sex.r, useNA = "ifany")}}

Let's do the same with \texttt{age} and \texttt{tattoos}. The column \texttt{age} should be an integer between 18 and 99, and the values of \texttt{tattoos} should be an integer between 0 and a maximum of (let's say) 100. Let's start by looking at the current values of each column using the \texttt{table()} function:

\begin{footnotesize}
<<>>=
table(pirates.errors$age)
table(pirates.errors$tattoos)
@
\end{footnotesize}

We can see some problems here: \texttt{age} has some negative values and a few very large values. Further, \texttt{tattoos} has a few negative values and a few values greater than 100. Let's convert all these troublesome values of \texttt{age} to NA.

\begin{footnotesize}
<<>>=
# Step 1: Copy age to a new column age.r
pirates.errors$age.r <- pirates.errors$age

# Step 2: See which values of age.r are valid
age.valid <- pirates.errors$age.r >= 18 & pirates.errors$age.r <= 99 # Step 2

# Step 3: Recode non-valid values to NA
pirates.errors$age.r[age.valid == FALSE] <- NA # Step 3
@
\end{footnotesize}

Now let's do the same for tattoos:

<<>>=
# Step 1: Copy tattoos to a new column tattoos.r
pirates.errors$tattoos.r <- pirates.errors$tattoos

# Step 2: See which values of tattoos.r are valid
tattoos.valid <- pirates.errors$tattoos.r %in% 0:100 # Step 2

# Step 3: Recode non-valid values to NA
pirates.errors$tattoos.r[tattoos.valid == FALSE] <- NA # Step 3
@



Now, let's look at the frequency tables of these recoded values:

\begin{footnotesize}
<<>>=
table(pirates.errors$age.r, useNA = "always")
table(pirates.errors$tattoos.r, useNA = "always")
@
\end{footnotesize}

In these examples, we converted invalid values to NA. Of course, there's no reason why we couldn't recode the values to other values. For example, we might recode values of \texttt{tattoos} greater than 50 to the maximum possible value of 50. To do this, we can just change the assignment in Step 3 to a value of \texttt{50} instead of NA.


\section{Splitting numerical data into groups using cut()}

When we create some plots and analyses, we may want to group numerical data into bins of similar values. For example, in our pirate survey, we might want to group pirates into age decades, where all pirates in their 20s are in one group, all those in their 30s go into another group, etc. Once we have these bins, we can calculate aggreagte statistics for each group.

R has a handy function for grouping numerical data called \texttt{cut()}



\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{cut()}\index{cut()}

\hline

\begin{description}

  \item[\tt{x}] \hfill \\
     A vector of numeric data
        \item[\tt{breaks}] \hfill \\
  Either a numeric vector of two or more unique cut points or a single number (greater than or equal to 2) giving the number of intervals into which x is to be cut. For example, \texttt{breaks = 1:10} will put break points at all integers from 1 to 10, while \texttt{breaks = 5} will split the data into 5 equal sections.
         \item[\tt{labels}] \hfill \\
An optional string vector of labels for each grouping. By default, labels are constructed using "(a,b]" interval notation. If labels = FALSE, simple integer codes are returned instead of a factor.
        \item[\tt{right}] \hfill \\
 A logical value indicating if the intervals should be closed on the right (and open on the left) or vice versa.

\end{description}

}
}
\vspace{5mm} %5mm vertical space

Let's try a simple example by converting the integers from 1 to 50 into bins of size 10:

\begin{footnotesize}
<<>>=
cut(1:50, seq(0, 50, 10))
@
\end{footnotesize}

As you can see, our result is a vector of factors, where the first ten elements are (0, 10], the next ten elements are (10, 20], and so on. In other words, the new vector treats all numbers from 1 to 10 as being the same, and all numbers from 11 to 20 as being the same.

Let's test the \texttt{cut()} function on the age data from \texttt{pirates}. We'll add a new column to the dataset called \texttt{age.binned}, which separates the age data into bins of size 10. This means that every pirate between the ages of 10 and 20 will be in the first bin, those between the ages of 21 and 30 will be in the second bin, and so on. To do this, we'll enter \texttt{pirates\$age} as the x argument, and \texttt{seq(10, 100, 10)} as the \texttt{breaks} argument:

\begin{footnotesize}
<<>>=
pirates$age.cut <- cut(x = pirates$age,  # The raw data
                       breaks = seq(10, 100, 10)  # The break points of the cuts
                       )
@
\end{footnotesize}

To show you how this worked, let's look at the first few rows of the columns \texttt{age} and \texttt{age.cut}

<<>>=
head(pirates[c("age", "age.cut")])
@

As you can see, \texttt{age.cut} has correctly converted the original age variable to a factor.

From these data, we can now easily calculate how many pirates are in each age group using \texttt{table()}

<<>>=
table(pirates$age.cut)
@


\section{Grouped aggregation}

As you can see, we have quite a bit of data in our Flights dataset. Many of the questions we might want to answer with this dataset have to do with comparisons between groups. For example, ``What is the flight cancellation rate for each carrier?" or "What is the arrival delay for each destination?" In each of these questions, we want to know a descriptive statistic of a numeric variable (cancellation rate and arrival delay) as a function of a nominal independent variable (carrier and destination). By now, your R skills are good enough that you \textit{could} answer these questions already. You could do this by using \texttt{subset()} or logical indexing to slice and dice the data set for each level of the independent variable. However, it would be a pain to have to manually create new subsets or indexes for each level of the independent variable. Thankfully, R contains many functions that will help you do this in a snap.

The first function we'll cover is \texttt{aggregate()}. The function \texttt{aggregate()} takes three arguments, a formula in the form  \texttt{y {\raise.17ex\hbox{$\scriptstyle\sim$}} x1 + x2} defining the dependent (Y) and one or more independent variables (x1, x2, ...), a function (FUN), and a dataframe (data). When you execute \texttt{aggregate(\texttt{y {\raise.17ex\hbox{$\scriptstyle\sim$}} x1 + x2 + ...}, data, FUN)}, R will apply the input function (FUN) to the dependent variable (Y) \textit{separately} for each level(s) of the independent variable(s) (x1, x2, ...). Let's see how it works:




\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{aggregate()}\index{aggregate()}

\hline

\begin{description}

  \item[\tt{formula}] \hfill \\
     A formula in the form \texttt{y {\raise.17ex\hbox{$\scriptstyle\sim$}} x1 + x2 + ...} where y is the dependent variable, and x1, x2... are the index (independent) variables. For example, \texttt{salary {\raise.17ex\hbox{$\scriptstyle\sim$}} sex + age} will aggregate a \texttt{salary} column at every unique combination of \texttt{age} and \texttt{age}
        \item[\tt{FUN}] \hfill \\
   A function that you want to apply to x at every level of the independent variables. For example, \texttt{FUN = mean} will calculate the mean of the data
         \item[\tt{data}] \hfill \\
The dataset containing the variables in \texttt{formula}
        \item[\tt{...}] \hfill \\
Optional arguments passed on to FUN (like \tt{na.rm = T} to ignore NA values in x)

\end{description}

}
}
\vspace{5mm} %5mm vertical space


Let's give \texttt{aggregate()} a whirl. We'll use the function to answer the question ``What is the flight cancellation rate for each carrier?" For this question, we'll set the value of Y to \texttt{cancelled}, x1 to \texttt{carrier}, and FUN to \texttt{mean}

\begin{footnotesize}
<<>>=
aggregate(formula = cancelled ~ carrier,  # DV is cancelled, IV is carrier
          FUN = mean, # Calculate the mean of the DV for each IV level
          na.rm = T, # Ignore NA values when calculating the mean
          data = Flights # IV and DV are located in the Flights dataframe
          ) 
@
\end{footnotesize}


As you can see, the \texttt{aggregate()} function has returned a dataframe with a column for the independent variable (\texttt{carrier}), and a column for the results of the function \texttt{mean} applied to each level of the independent variable. We can easily plot these data using the \texttt{barplot()} function, which plots a numeric variable as a function of a nominal variable (see margin Figure~\ref{fig:barplot})

\begin{marginfigure}
\begin{tiny}
<<fig.height = 6, fig.width = 6>>=
aggregated.data <- aggregate(formula = cancelled ~ carrier, 
                             FUN = mean, na.rm = T, data = Flights)

barplot(height = aggregated.data$cancelled,
        names.arg = aggregated.data$carrier)
@
\end{tiny}
\caption{Barplot showing the mean flight cancellation rate for airlines in the \texttt{Flights.txt} dataset}
\label{fig:barplot}
\end{marginfigure}

You can include any function as the argument to \texttt{FUN} as long as the function takes a single numeric argument and returns a single scalar. For example, let's use \texttt{aggregate()} to now get the median arrival and departure delays for each airline carrier:

\begin{footnotesize}
<<>>=
# Calculate median departure delay by carrier
 med.arrdelay <- aggregate(formula = arr_delay ~ carrier, # DV is arr_delay, IV is carrier
            FUN = median, # Calculate the median arr_delay
            data = Flights, # Columns are in the Flights dataframe
            na.rm = T) # Ignore NA values
     

# Calculate median  departure delay by carrier
med.depdelay <- aggregate(formula = dep_delay ~ carrier, 
            FUN = median,
            data = Flights,
            na.rm = T) # Ignore NA values

@

\end{footnotesize}

Let's combine two results from \texttt{aggregate()} into one plot. In margin Figure~\ref{fig:flightsdelay}, I compare the median arrival and departure delays for each airline. Interestingly, we can see that the carrier US has both a very low median arrival and departure delay. In fact, they're both negative, suggesting that US flights tend to leave and arrive early. In contrast, the carrier UA has a median arrival and departure delay of 0. If you ask me, UA has the better numbers as their flights, on average, depart and arrive when they are supposed to!

\begin{marginfigure}
\begin{tiny}
<<fig.width = 5, fig.height = 5>>=
require("RColorBrewer")

# Step 1: Calculate median arrival delays
med.arrdelay <- aggregate(formula = arr_delay ~ carrier, 
            FUN = median,
            data = Flights,
            na.rm = T) # Ignore NA values
     

# Step 2: Calculate median departure delays
med.depdelay <- aggregate(formula = dep_delay ~ carrier, 
            FUN = median,
            data = Flights,
            na.rm = T) # Ignore NA values

# Step 3: Set up plot and add reference line
plot(1, xlim = c(-10, 10), ylim = c(-5, 5), 
     type = "n", main = "Aggregate Carrier Flight Delays",
     xlab = "Arrival Delay",  ylab = "Departure Delay")

abline(h = 0, lty = 2, col = "gray")
abline(v = 0, lty = 2, col = "gray")

# Step 4: Add points
points(x = med.arrdelay$arr_delay, 
       y = med.depdelay$dep_delay,
       col = brewer.pal(12, "Set3"),
       pch = 16, cex = 1.5
       )

# Step 5: Add carrier labels
text(x = med.arrdelay$arr_delay,
     y = med.depdelay$dep_delay,
    labels = med.depdelay$carrier,
    pos = c(rep(1, 5), 3, rep(1, 9)) # Insert 3 for carrier EV
     )

@
\end{tiny}
\caption{Median arrival and departure delay for each airline carrier in the \texttt{Flights} dataset.}
\label{fig:flightsdelay}
\end{marginfigure}


While \texttt{aggregate()} is good for calculating summary statistics for a single dependent variable, it can't handle multiple dependent variables. For example, if you had a survey and you wanted to calculate summary statistics for multiple dependent variables (like income, weight, age, etc.), you'd need to execute an \texttt{aggregate()} command for each dependent variable, and then combine the results into a single dataframe. Thankfully, a recently released R package called \texttt{dplyr} makes this process very simple!

\section{Aggregation with dplyr}

The \texttt{dplyr} package is a new package that allows you to do data `wrangling' (manipulating datasets) quickly and easily. In this section, we'll go over a very brief overview of how the functions in dplyr work. However, this will be a very brief overview and I strongly recommend you look at the help menu for dplyr for additional descriptions and examples.

dplyr works by combining objects (dataframes and columns in dataframes), functions (mean, median, etc.), and \textit{verbs} (special commands in \texttt{dplyr}). In between these commands is a new operator called the \textit{pipe} which looks like this: \texttt{\%>\%}. The pipe simply tells R that you want to continue executing some functions or verbs on the object you are working on. You can think about this pipe as meaning 'and then...'

To aggregate data with \texttt{dplyr}, your code will look something like the following code. In this example, assume that the original (raw) dataframe is called 
\texttt{my..df}, the variable you want to collapse the data over is called \texttt{grouping.column}, and the columns you want to aggregate are called \texttt{col.a}, \texttt{col.b} and \texttt{col.c}

<<eval = F>>=
my.df %>%  # Specify original dataframe
    group_by(grouping.column) %>% # Grouping variable
    summarise(
      a.mean = mean(col.a),  # calculate mean of column col.a in my.df
      b.sd = sd(col.b),      # calculate sd of column col.b in my.df
      c.max = max(col.c)     # calculate max on column col.c in my.df, ...
      )
@

Here's how you should think about the code above:

\begin{displayquote}
Start with the dataframe \texttt{my.df}. \textit{Then}, group \texttt{my.df} by the grouping variable \texttt{grouping.variable}. \textit{Then}, calculate the following summary columns in the dataset: \texttt{a.mean} should be the mean of \texttt{col.a} in my.df, \texttt{b.sd} should be the standard deviation of \texttt{col.b} in my.df, and \texttt{c.max} should be the maximum value of \texttt{col.c} in my.df.
\end{displayquote}

When you use dplyr, you write code that sounds like: "The original dataframe is XXX, now filter the dataframe to only include rows that satisfy the conditions YYY, now group the data at each level of the variable(s) ZZZ, now summarize the data and calculate summary functions XXX..."


Let's start with an example: Let's create a dataframe of aggregated data from the \texttt{Flights} dataset, where each row is a airline carrier, and each columns is a different summary statistic of some data across all flights. Specifically, let's create 5 columns: \texttt{dep.delay.med}, The median departure delay of that airline, \texttt{dep.delay.sd}: The standard deviation of departure delays of that airline, \texttt{arr.delay.max}: The maximum departure delay of that airline, and \texttt{dist.mean}: The average flight distance of that airline.

To create this aggregated data frame, I will use the new function \textt{group\_by} and the verb \texttt{summarise}. I will assign the result to a new dataframe called \texttt{flights.agg}:

\begin{footnotesize}
<<message = F>>=
require(dplyr)
flights.agg <- Flights %>% # Define dataframe, THEN...
                group_by(carrier) %>% # Define the grouping variable, THEN...
  summarise( # Tell R you are going to calculate summaries
    dep.delay.med = median(dep_delay, na.rm = T), # Define first summary...
    dep.delay.sd = sd(dep_delay, na.rm = T),  # Define second summary...
    arr.delay.max = max(arr_delay, na.rm = T),
    dist.mean = mean(dist, na.rm = T)
  ) # End

flights.agg # Print result!
@
\end{footnotesize}

As you can see, our final object \texttt{flights.agg} is the aggregated dataframe we want which aggregates all the columns we wanted at the level of the airline carrier. Let's walk through the code

\marginnote{When you use dplyr, the output will always be an object called a \textit{local data frame}. A local dataframe is identical to a regular dataframe, except that it looks a bit nicer if you print the entire dataframe into the console. This means you don't have to use the \texttt{head()} function when looking at a local dataframe.}

\begin{itemize}
  \item First, we define the original dataframe that we are basing our summary statistics on. In this case, the original dataframe is \texttt{Flights}. We then include the pipe \texttt{\%>\%} to tell R we are still working.
  \item Second, we define the grouping variable using the \texttt{group\_by} function. This tells R to group the results at the level of each carrier. We then use the \texttt{\%>\%} pipe.
  \item Next, we call the \texttt{summarise} function, which tells R that the following functions will be summaries of the grouping variable. Because all the arguments to the \texttt{summarise} function are within the parentheses, we don't need to use a pipe.
  \item Finally, we define the summary columns in our final dataframe. For each column, we give it a name (e.g.; \texttt{dep.delay.med}), and then write the calculation as a function of the appropriate columns in the original dataframe. For example, to define \texttt{dep.delay.med}, we write \texttt{median(dep\_delay, na.rm = T)}.
  
\end{itemize}

Hopefully you can see that this \texttt{dplyr} code is \textit{much} simpler than the code we'd have to use if we wanted to create all these summary columns using \texttt{aggregate}.

\subsection{The 5 verbs in dplyr}

In the example above, we used the \texttt{dplyr} verb \texttt{summarise}. However, dplyr has other verbs that are just as useful:

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{dplyr verbs}\index{dplyr()}

\hline

\begin{description}

\item[\tt{filter}] \hfill \\
Select a subset of rows in a dataframe. For example, the following code will restrict data to males

\item[\tt{arrange}] \hfill \\
  Reorders rows of a dataframe.
  
  \item[\tt{select}] \hfill \\  
Select specific columns of a dataframe.

\item[\tt{mutate}] \hfill \\  
Add a column to a dataframe. 

\item[\tt{summarise}] \hfill \\  
 Creates summary columns as a function of columns in the original dataframe. Note: Only use after specifying \texttt{group\_by} variables.

\end{description}

}
}
\vspace{5mm} %5mm vertical space

Let's do an example where we combine multiple verbs into one chunk of code. We'll create a new dataframe called \texttt{flights.cancelled} that gives us data on the cancelled flights from each airline. However, let's add some additional data filters this time. We'll filter the data to only include flights that were scheduled to depart before 12pm, and whose destination is either DFW (Dallas Fort Worth), MIA (Miami), or DSM (Des Moines). 

\begin{footnotesize}
<<>>=
require(dplyr)
flights.agg <- Flights %>% # Step 1
            filter(hour < 12 & dest %in% c("DFW", "MIA", "DSM")) %>% # Step 2
            group_by(carrier) %>% # Step 3
            summarise( # Step 4
              cancelled.p = mean(cancelled), # Step 5
              n = length(cancelled) # Step 6
            ) %>%
            arrange(n) # Step 7

flights.agg # Print the result!
@
\end{footnotesize}

As you can see, our result is a dataframe with 5 rows and 3 columns. The reason why we only have 5 rows is because only 5 carriers had flights to one of the three airports we specified. Let's walk through the code line by line:

\begin{enumerate}

  \item First, we define the original dataframe as \texttt{Flights}, (\%>\% then...)
  \item Next we filter the \texttt{Flights} dataframe by only including rows where the hour is less than 12, and the destination is in the set DFW, MIA and DSM. (\%>\% then...)
  \item We group the data according to \texttt{carrier} (\%>\% then...)
  \item We call the \texttt{summarise} verb, telling dplyr that the next commands are summary functions of \texttt{Flights}. These will be the columns in our new aggregated dataframe. (\%>\% then...)
  \item The first column in our new aggregated dataset is called \texttt{cancelled.p} and is defined as the mean value of the \texttt{cancelled} column in \texttt{Flights}. 
  \item The second column is called \texttt{n} and is simply the length of the vector \texttt{cancelled}. Because this function is called for each level of \texttt{carrier}, this will give us the number of observations for each level of \texttt{carrier}.
    \item Arrange the final dataframe by the new column \texttt{n}
  
\end{enumerate}


\section{Merging two dataframes}

Merging two dataframes together allows you to combine information from both dataframes into one. For example, a teacher might have a dataframe called \texttt{students} containing information about her class. She then might have another dataframe called \texttt{exam1scores} showing the scores each student received on an exam. To combine these data into one dataframe, you can use the \texttt{merge()} function. For those of you who are used to working with Excel, \texttt{merge()} works a lot like \texttt{vlookup} in Excel:


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{merge()}\index{merge()}

\hline

\begin{description}

  \item[\tt{x, y}] \hfill \\
      2 dataframes to be merged
  \item[\tt{by, by.x, by.y}] \hfill \\
   The names of the columns that will be used for merging. If the the merging columns have the same names in both dataframes, you can just use \texttt{by = c("col.1", "col.2"...)}. If the merging columns have different names in both dataframes, use \texttt{by.x} to name the columns in the x dataframe, and \texttt{by.y} to name the columns in the y dataframe. For example, if the merging column is called \texttt{STUDENT.NAME} in dataframe x, and \texttt{name} in dataframe y, you can enter \texttt{by.x = "STUDENT.NAME", by.y = "name"}
  \item[\tt{all.x, all.y}] \hfill \\  
A logical value indicating whether or not to include non-matching rows of the dataframes in the final output. The default value is \texttt{all.y = FALSE}, such that any non-matching rows in y are not included in the final merged dataframe. 
\end{description}

}
}
\vspace{5mm} %5mm vertical space

A generic use of \texttt{merge()},  looks like this:

<<eval = F >>=
new.df <- merge(x = df.1,  # First dataframe
                y = df.2,  # Second dataframe
                by = "column"  # Common column name in both x and y
                )
@

where \texttt{df.1} is the first dataframe, \texttt{df.2} is the second dataframe, and \texttt{"column"} is the name of the column that is common to both dataframes.

For example, let's say that we wanted to add a column to our happiness dataframe \texttt{hsurvey} showing the continent that each person was from. In the dataframe, we only have country information, so how can we add continent info? We can do this by merging the \texttt{hsurvey} dataframe with a new dataframe called \texttt{continents}. By merging the dataframes, we will add all the information from \texttt{contents} to the \texttt{hsurvey} dataframe as additional rows. We'll also match the two dataframes with the column \texttt{country}.

\begin{footnotesize}
<<>>=
continents <- data.frame(country = c("USA", "Canada", "Mexico", "India", "Portugal"),
                         continent = c("North America", "North America", "North America", "Asia", "Europe"),
                         gdp = c(53042, 51964.3, 10307.3, 1497.5, 21738.3),
                         stringsAsFactors = F
                         )

hsurvey <- merge(x = hsurvey, # The first dataframe
                 y = continents, # The second dataframe
                 by = "country" # The name of the matching column
                 )
@
\end{footnotesize}

To see if this worked, let's look at the first few rows of \texttt{hsurvey}

\begin{footnotesize}
<<>>=
head(hsurvey)
@
\end{footnotesize}

As you can see, our new merged dataframe has added the information from \texttt{continents} to the \texttt{hsurvey} dataframe by matching rows with the \texttt{country} column.

\subsection{Easily recode values in a dataframe with merge()}

You can also use the \texttt{merge()} function to quickly recode values in a vector in a dataframe. For example, let's say some drunk pirate accidentely entered the wrong country names for each person in the column \texttt{country} in \texttt{hsurvey()}. Thankfully, when we got him sober enough he could tell us which (incorrect) entry goes to which correct entry. For example: the entry USA should be Canada, Mexico should be India, etc. We can quickly correct this in our original dataframe using \texttt{merge()}. We'll do this in two steps:

\begin{enumerate}
\item Create a lookup table that shows the original (incorrect) and the new (correct) values
\item Merge the the original data with the lookup table
\end{enumerate}

Let's create the lookup table called \texttt{lookup}. This will be a dataframe with two columns: \texttt{country.wrong} - the original country values, and \texttt{country.true} the corrected values. Each row in the dataframe will connect the original incorrect value with the new, correct value.

\begin{footnotesize}
<<>>=
lookup <- data.frame("country.wrong" = c("USA", "Canada", "Mexico", "India", "Portugal"),
                     "country.true" = c("Canada", "Mexico", "India", "Portugal", "USA")
                     )
@
\end{footnotesize}

Now, let's merge \texttt{hsurvey} with \texttt{lookup}. To do this, we'll need to specify that the matching column in \texttt{hsurvey} is called \texttt{country}, and the matching column in \texttt{lookup} is called \texttt{country.wrong}. When we merge these two dataframes, R will add the \texttt{country.true} column to \texttt{hsurvey}


<<>>=
hsurvey <- merge(x = hsurvey,
      y = lookup,
      by.x = "country",
      by.y = "country.wrong"
      )
@


Let's see if it worked:
\begin{footnotesize}
<<>>=
head(hsurvey)
@
\end{footnotesize}




%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{10: 1 and 2-sample Null-Hypothesis tests}
\label{ch:10}


Chapter Goals

\begin{enumerate}
  \item Learn about hypothesis test objects in R
  \item One and two sample tests: Correlations, t-tests and chi-square
\end{enumerate}

Do we get more treasure from chests buried in the sand or at the bottom of the ocean? Is there a relationship between the number of scars a pirate has and how much grogg he can drink? Are pirates with nipple rings more likely to wear bandannas than those without nipple rings? Glad you asked, let's see how we can answer these questions some hypothesis tests.

\section{Warning about null-hypothesis tests with "frequentist" statistics}

\begin{marginfigure}
\includegraphics[width=\linewidth]{/Users/Nathaniel/Dropbox/Git/YaRrr_Book/media/xkcdbayes.png}
\caption{xkcd comic. Currently used without any permission.}
\label{fig:xkcdbayes}
\end{marginfigure}

Until recently, null-hypothesis testing using frequentist statistics has been the most popular method of conducting inferential statistics. However, it has serious flaws. While I can't go into the details here, I can point out that the main flaw is that frequentist statistics don't give you the information you really want to know. For example, imagine that you are comparing the effectiveness of a cancer drug to a placebo. After conducting a double-blind study, where you give some patients the placebo and some patients the drug, you want to know the probability that that the drug is better than a placebo. Unfortunately frequentist statistics cannot give you this information. They can only tell you the probability of getting a specific result \textit{given} that the null hypothesis (in this case, that the drug is equally as effective as the placebo) is true. If that sounds confusing, it's because it is. A better alternative is Bayesian statistics which \textit{can} give you posterior probability information. Unfortunately, Bayesian statistics can be computationally demanding, so in the past we've lived with frequentist statistics and tried to ignore its fundamental flaws. However, given improvements in processing speed, we can now easily conduct Bayesian alternatives to frequentist tests on modern computers.

We will cover Bayesian statistics in Chapter X and I strongly encourage you to adopt them in your own analyses. However, for the purposes of completeness, I'll show you how to conduct most of the standard frequentist tests here.

\section{T-test}\index{t-test}


We use t-tests to compare the sample mean of data to some hypothesized mean. In a one sample test, we use one set of observations to test whether or not the population mean is different from a hypothesized value. In a two-sample test, we use two sets of observations to test whether or not the two populations have different means.

The t-test function in R is \texttt{t.test()}. The \texttt{t.test()} function can take several arguments, here I'll emphasize a few of them. To see them all, check the help menu for t.test (\texttt{?t.test}).

\marginnote{\texttt{t.test(x, y)}: Conduct either a one sample t-test on a vector x, or a two-sample t-test on two vectors x and y.}

There are two ways to use the \texttt{t.test()} function. The first way is to enter one (or more) vectors as arguments to the function as follows:


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{t.test(x, y)}\index{t-test!t.test()}

\hline

\begin{description}

  \item[\tt{x, y}] \hfill \\
      Either one vector of data (x) for a one-sample t-test, or two vectors (x, y) for a two-sample test.

  \item[\tt{alternative}] \hfill \\
    A character string indicating whether the test is two-tailed or one-tailed (including the direction). Type "t" for two-tailed, "g" for a 'greater than' one-tailed test, or "l" for a "less than" one-tailed test.
  \item[\tt{mu}] \hfill \\  
  he population mean under the null hypothesis.
  \item[\tt{paired, var.equal}] \hfill \\
  \texttt{paired}: A logical value (either T or F) indicating whether the test is paired (T) or unpaired (F). Only use this for two-sample tests.
  
  \texttt{var.equal}:   A logical value indicating whether or not you treat the two variances as equal.
\end{description}

}
}
\vspace{5mm} %5mm vertical space

Let's do an example using the pirate survey dataset. If you haven't downloaded the pirate survey dataset, check Chapter 1 for instructions.

\subsection{One-Sample t-test}

The format for a one-sample t-test is as follows:

<<eval = F>>=
t.test(x = data,  # A vector of data
       mu = 0, # The null hypothesis
       alternative = "t" # Two tailed test (use "l" or "g" for one-tailed)
       )
@

where \texttt{x} is a vector of data, \texttt{mu} is the population mean under the null hypothesis, and \texttt{alternative} is \texttt{``t"} for a two-tailed test, or \textt{``l"} or \texttt{``g"} for a one-tailed test.

\begin{marginfigure}
\begin{tiny}
<<fig.width = 5, fig.height = 5>>=
par(mar = c(10, 0, 3, 1))
plot(1, xlim = c(-10, 10), ylim = c(0, 1), 
     yaxt = "n", main = "One Sample t-test", 
     type = "n", bty = "n", ylab = "", xlab = "")

samples <- rnorm(100, mean = 3, sd = 2)

par(new = T)
hist(samples, yaxt = "n", xaxt = "n", xlab = "", 
     ylab = "", main = "", xlim = c(-10, 10))

mtext(paste("Sample Mean\n", round(mean(samples), 2), sep = ""), 
      side = 1, line = 3.5, at = mean(samples))

abline(v = mean(samples), lty = 1, col = "blue", lwd = 4)

mtext("Null Hypothesis\nMu = 0", side = 1, line = 6, at =0)
abline(v = 0, lty = 1, col = "red", lwd = 4)

@
\end{tiny}
\end{marginfigure}

Let's do a one-sample t-test on the age of pirates in our survey. Specifically, let's see if the average age of the pirates is significantly different from 20. In this case, our vector x is \texttt{pirates\$age}:


<<>>=
test.result <- t.test(x = pirates$age, # Vector of data to test
                      mu = 20,   # Null hypothesis is mean = 30
                      alternative = "t" # Two-tailed test
                      )
@


You'll notice that when you assign the t.test to an object (in this case we called it \texttt{test.result}), you do not see any output. To see the output of the test, you need to tell R to print the object by executing the name of the test object:

\begin{footnotesize}
<<>>=
test.result  # Print the results of the t.test
@
\end{footnotesize}

Now, you can see the main output of the test. Looks like we got a test statistic of \Sexpr{round(test.result$statistic, 2)} and a resulting p-value that's pretty darn small. But what if you want to access specific values like the test statistic or the p-value? Thankfully, this is easy in R. To see which information you can extract from the t-test object, apply the \texttt{names()} function to the test object:

\marginnote{If you want to see what information is in a test object, just apply \texttt{names()} to the object. You can then extract specific information with \$}

\begin{footnotesize}
<<>>=
names(test.result)
@
\end{footnotesize}

From this vector of names, I see that I can extract the test statistic with the name \texttt{statistic} and the p-value with the name \texttt{p.value}. To get these from the test object, use the \$ operator:

\begin{footnotesize}
<<>>=
test.result$statistic  # Show me the test statistic
test.result$p.value # Show me the p.value
@
\end{footnotesize}

Being able to quickly extract key numerical information from a test object is huge. For one thing, it allows you to automate the process of running statistical tests over different datasets or simulations. In Chapter XX, we'll see how you can use loops to do this in a snap.

\subsection{Two-sample t-test}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 5, fig.height = 5>>=
par(mar = c(10, 0, 3, 1))
plot(1, xlim = c(-10, 10), ylim = c(0, 1), 
     yaxt = "n", main = "Two Sample t-test", 
     type = "n", bty = "n", ylab = "", xlab = "")

samples.1 <- rnorm(100, mean = 3, sd = 2)

par(new = T)
hist(samples.1, yaxt = "n", xaxt = "n", xlab = "", 
     ylab = "", main = "", xlim = c(-10, 10), 
     col = rgb(0, 0, 1, alpha = .1))

mtext(paste("Sample Mean\n", round(mean(samples.1), 2), sep = ""), 
      side = 1, line = 3.5, at = mean(samples.1))

abline(v = mean(samples.1), lty = 1, 
       col = rgb(0, 0, 1, alpha = 1), lwd = 4)

samples.2 <- rnorm(100, mean = -3, sd = 2)

par(new = T)
hist(samples.2, yaxt = "n", xaxt = "n", xlab = "", 
     ylab = "", main = "", xlim = c(-10, 10), 
     col = rgb(1, 0, 0, alpha = .1))

mtext(paste("Sample Mean\n", round(mean(samples.2), 2), sep = ""), 
      side = 1, line = 3.5, at = mean(samples.2))

abline(v = mean(samples.2), lty = 1, 
       col = rgb(1, 0, 0, alpha = 1), lwd = 4)

mtext("Null Hypothesis\nMu = 0", side = 1, line = 6, at =0)

abline(v = 0, lty = 2, col = "black", lwd = 4)

@
\end{tiny}
\end{marginfigure}

In a two-sample t-test, we use two sets of observations drawn from two different populations and test whether or not the two populations have the same mean. To conduct a two-sample t-test, we simply enter two vectors as arguments \texttt{x} and \texttt{y}. 

Let's use this convention to compare the ages of pirates who wear headbands and pirates who don't wear headbands. First, we'll create the two vectors \texttt{age.headband} and \texttt{age.noheadband} containing the age data for pirates who do and do not wear headbands. We'll then enter these vectors as arguments \texttt{x} and \texttt{y} to \texttt{t.test()}:

\begin{footnotesize}
<<>>=
age.headband <- subset(pirates, subset = headband == "yes")$age  # Get the first vector
age.noheadband <- subset(pirates, subset = headband == "no")$age  # Get the second vector

test.result <- t.test(x = age.headband, # Enter the first vector
                      y = age.noheadband, # Enter the second vector
                      alternative = "two.sided" # Specify a two-tailed test
                      )
test.result  
@
\end{footnotesize}

Looks like we see a test statistic of \Sexpr{round(test.result$statistic, 2)} with a resulting p-value of \Sexpr{round(test.result$p.value, 2)}. According to null-hypothesis test logic, we fail reject the null hypothesis.

\subsection{Specifying t-tests with formula notation}

The second (and I think better) way to specify arguments to the \texttt{t.test()} function is by using the \texttt{formula} and \texttt{subset} arguments. Using this notation, we specify the dependent and independent variables as a formula in the form  \texttt{dv {\raise.17ex\hbox{$\scriptstyle\sim$}} iv} where \texttt{dv} is the dependent variable, and \texttt{iv} is the independent variable with two levels in a dataframe. As you'll see, this convention is a bit nicer to use when working with data in dataframes because we don't need to define two separate vectors prior to the test.

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{t.test(formula, data)}\index{t-test!t.test()}

\hline

\begin{description}

\item[\tt{formula}] \hfill \\
    An (optional) formula in the form \texttt{dv {\raise.17ex\hbox{$\scriptstyle\sim$}} iv} where \texttt{dv} is the dependent variable, and \texttt{iv} is the independent variable with two levels in a dataframe. Specify the dataframe in the \texttt{data} argument
\item[\tt{data}] \hfill \\
    The dataframe containing the columns specified in \texttt{formula}.
\item[\tt{subset}] \hfill \\
  A logical vector indicating a subset of data to use. If the independent variable in the formula specification has more than two values, you'll need to use \texttt{subset} to restrict the data to only two values of the iv.
\item[\tt{alternative, mu, paired, var.equal}] \hfill \\  
    Additional arguments (see previous \texttt{t.test()} description)
\end{description}

}
}
\vspace{5mm} %5mm vertical space

Using this formulation, we don't have to define separate vectors (x and y) prior to conducting the test. Instead, we can use the \texttt{formula} argument to tell R which columns in a dataframe correspond to the dependent and independent variables. When you use the formula version of t.test, the independent variable \textit{must} only have two possible values. If R finds more than two values in the iv, it will return an error. To ensure that there are only two values present, include the appropriate \texttt{subset} argument. For example, if the independent variable is \texttt{sex} and you want to compare males and females, include the argument \texttt{subset = sex \%in\% (c("male", "female"))}

Let's repeat the previous t-test using a formula. To do this, we'll specify three new arguments:

\begin{itemize}
\item \texttt{data = pirates}: The columns in \texttt{formula} come from the dataframe \texttt{pirates}
\item \textt{formula = age {\raise.17ex\hbox{$\scriptstyle\sim$}} headband}: Conduct a test on \texttt{age} as a function of \texttt{headband}. 
\item \texttt{subset = headband \%in\% c("yes", "no")}: Restrict our analysis to pirates who answered \texttt{"yes"} or \texttt{"no"} to whether or not they wear a headband.
\end{itemize}

Here's how the alternative notation for the same test looks:

<<>>=
test.result <- t.test(formula = age ~ headband,  #dv is weight, iv is Diet
                      subset = headband %in% c("yes", "no"),  # Only use valid headband values
                      data = pirates, # Dataframe is pirates
                      alternative = "two.sided" # Two-sided test
                      )
test.result 
@

As you can see, the results of this test and the prior test are identical. You can use which ever version makes more sense to you. Personally, I like the formula version because all the necessary commands (including the specification that the two diets are 1 and 2) are contained within the \texttt{t.test()} function. Of course, you can also specify additional restrictions in the \texttt{subset} argument.

Let's try making the previous test a little more complicated by adding a \texttt{subset} argument. Let's say a pirate tells you "Oh, well there's only a difference between the age of headband and no-headband pirates for those pirates who went to college at Captain Chunk's Canon Crew." We can test this by addding the additional restriction \texttt{college == "Captain Chunk's Canon Crew}, to the \texttt{subset} argument:

<<>>=
test.result <- t.test(formula = age ~ headband,
                      subset = headband %in% c("yes", "no") &
                               college == "Captain Chunk's Canon Crew",
                      data = pirates,
                      alternative = "two.sided"
                      )
test.result 
@

Looks like we still don't find a significant difference in age between headband and no-headband wearers, even just for pirates who went to Captain Chunk's Canon Crew.


\section{Correlation test}\index{correlation}

\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=

x <- rnorm(n = 100, mean = 10, sd = 10)
y <- x + rnorm(n = 100, mean = 0, sd = 10)

plot(x, y, main = "cor.test(x, y)")
abline(lm(y ~ x))

legend("topleft", 
       legend = paste("cor = ", round(cor(x, y), 2), sep = ""),
       lty = 1)

@
\end{tiny}
\end{marginfigure}


Next we'll cover two-sample correlation tests. Recall that in a correlation test, you are accessing the relationship between two variables on a ratio or interval scale.

To run a correlation test, use the \texttt{cor.test(x, y)} function. The test has the following arguments

\marginnote{\texttt{cor.test(x, y)}: Conduct a correlation test between two vectors x and y.}

\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{cor.test()}\index{cor.test()}

\hline

\begin{description}

\item[\tt{x, y}] \hfill \\
    Two numeric data vectors of the same length
\item[\tt{alternative}] \hfill \\
    A string indicating the direction of the test. You can use "t" for two-sided, "l", for less than, and "g" for greater than.
\item[\tt{method}] \hfill \\  
    A string indicating which correlation coefficient to test. You can use "pearson", "kendall", or "spearman". The default is Pearson.
    \item[\tt{conf.level}] \hfill \\  
   The confidence level for the Pearson correlation coefficient.
\end{description}

}
}
\vspace{5mm} %5mm vertical space


Let's conduct a correlation test on the age of pirates and the number of parrots they've had in their lifetime. We'll set \textt{x = pirates\$age}, and \texttt{y = pirates\$parrots.lifetime}

\begin{footnotesize}
<<>>=
test.result <- cor.test(x = pirates$age, 
                        y = pirates$parrots.lifetime
                        )

test.result
@
\end{footnotesize}

Looks like we have a positive correlation of \Sexpr{round(test.result$estimate, 2)}! To see what information we can extract for this test, let's run the command \texttt{names()} on the test object:

\begin{footnotesize}
<<>>=
names(test.result)
@
\end{footnotesize}

Looks like we've got a lot of information in this test object. As an example, let's look at the confidence interval:

\begin{footnotesize}
<<>>=
test.result$conf.int
@
\end{footnotesize}

You'll notice that when we tried to access the confidence interval, we got an additional piece of information called \texttt{attr(,"conf.level")}. This means that the result of the command \texttt{test.result\$conf.int} not only contains the bounds of the confidence interval, but also the level of confidence. This is a good thing because the confidence interval only makes sense in terms of the level of confidence used to calculate the interval.

\section{Chi-square test}

Next, we'll cover chi-square tests. In  a chi-square test test, we test whether or not there is a relationship between two variables on a nominal scale (like sex, eye color, first name etc.). To conduct a chi-square test, we use the \texttt{chi.square()} function.


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{chisq.test()}\index{chisq.test()}

\hline

\begin{description}

\item[\tt{x, y}] \hfill \\
    Two vectors (can be numeric, factor, or string) of the same length. Alternatively, you can simply enter a matrix as the x argument and ignore the y argument.
\item[\tt{correct}] \hfill \\
    a logical indicating whether to apply continuity correction when computing the test statistic for 2 by 2 tables: one half is subtracted from all |O - E| differences; however, the correction will not be bigger than the differences themselves.
\end{description}

}
}
\vspace{5mm} %5mm vertical space

Let's use the \texttt{chisq.test()} function to test if there is a relationship between the college a pirate went to and the type of sword he/she uses. We'll use the tattoo and college vectors in \texttt{pirates}


\begin{footnotesize}
<<>>=
test.result <- with(pirates, 
                    chisq.test(x = college, 
                              y = sword.type)
                    )

test.result
@
\end{footnotesize}

Looks like we got a test-statistic of \Sexpr{round(test.result$statistic, 2)} and a p-value of \Sexpr{round(test.result$p.value, 2)}. According to this test, we do not have sufficient data to reject the null hypothesis that there is no relationship between the two variables.

Let's see what other information we can get from the chi-squre test object:

\marginnote{I encourage you to run the \texttt{names()} function on statistical objects. You never know what interesting things you'll discover!}

\begin{footnotesize}
<<>>=
names(test.result)
@
\end{footnotesize}

We've got some interesting new options here. Let's look at the value of \texttt{observed}, the observed frequencies in the data

\begin{footnotesize}
<<>>=
test.result$observed
@
\end{footnotesize}

Cool. It looks like R stores a table of the observed frequencies and the expected frequencies under the null-hypothesis. Thanks R!




%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{11: Regression and ANOVA}
\label{ch:11}


Chapter Goals

\begin{enumerate}
  \item Learn about regression
  \item ANOVA
\end{enumerate}

\section{The Linear Model}\index{Linear Model}

The linear model is easily the most famous and widely used model in all of statistics. Why? Because it can apply to so many interesting research questions where you are trying to predict a variable of interest (the \textit{response} or \textit{dependent variable}) on the basis of one or more other variables (the \textit{predictor} or \textit{independent variables}).

The linear model takes the following form:

\begin{Large}
\begin{equation*}
y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+...\beta_{n}x_{n}
\end{equation*}
\end{Large}

where the x values represent the predictors, while the beta values represent weights.

To use the linear model in R, we use the \texttt{lm()} function:





\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{lm()}\index{lm()}

\hline

\begin{description}

\item[\tt{function}] \hfill \\
A function in a form \texttt{y {\raise.17ex\hbox{$\scriptstyle\sim$}} x1 + x2 + ...}, where y is the dependent variable, and x1, x2, ... are the independent varaibles.

\item[\tt{data}] \hfill \\
  The dataframe containing the columns specified in the formula.
  
  \item[\tt{subset}] \hfill \\  
An optional vector specifying a subset of observations to be used in the fitting process. For example \texttt{subset = age > 50}

\end{description}

}
}
\vspace{5mm} %5mm vertical space

Let's try an example with some made-up data. For this example, I'll create three independent variables x1, x2 and x3 from normal distributions. I'll then create a dependent variable \texttt{y} as a linear function of the three independent variables (with a little error thrown in)\footnote{If there was no error in the model, then the response variable would be a perfect linear combination of the predictor variables. When this happens, the model will always perfectly fit the data and no stats are necessary (or even possible!)}. Finally, I'll run the linear model and see if we can recover the true beta values:

\begin{footnotesize}
<<>>=
# Step 1: Create a dataframe of predictors

random.data <- data.frame(
             "x1" = rnorm(100, mean = 0, sd = 1),
             "x2" = rnorm(100, mean = 4, sd = 5),
             "x3" = rnorm(100, mean = -2, sd = 2)
             )

# Step 2: Create the DV with beta values 0, 1, 2, 3
random.data$y <- with(random.data, 0 + 1 * x1 + 2 * x2 + 3 * x3)

# Step 3: Add some random noise to the DV
random.data$y <- random.data$y + rnorm(100, mean = 0, sd = 1)

# Step 4: Run the model then print the result
result <- lm(y ~ x1 + x2 + x3, data = random.data)
result
@
\end{footnotesize}

Looks like our estimated beta values of \Sexpr{round(result$coefficients[1], 4)}, \Sexpr{round(result$coefficients[2], 4)}, \Sexpr{round(result$coefficients[3], 4)} and \Sexpr{round(result$coefficients[4], 4)} are pretty close to the true values of 0, 1, 2, 3! This means the model did a pretty good job of estimating the true beta values from the (noisy) data. 

We can get lots of other information from the linear model object. Here are three of them (to see all of them, run \texttt{names(result)}):

\begin{itemize}
  \item \texttt{coefficients}: A vector of the estimated beta values
  \item \texttt{residuals}: A vector of the differences between the true response values and the fitted response values.
  \item \texttt{fitted.values}: A vector of the fitted values.
\end{itemize}

These attributes let us easily calculate some interesting model diagnostics. For example, let's see how far the model fits are on average from the true values:

\begin{footnotesize}
<<>>=
abs.resid <- abs(result$residuals) # Calculate the absolute value of the residuals
mean(abs.resid) # Calculate the mean
@
\end{footnotesize}

So it looks like, on average, our model fits are \Sexpr{round(mean(abs.resid), 2)} off from the true values (This value is driven by the standard deviation in errors, which we set to 1).

The linear model assumes that there should be no relationship between the predicted values and the distribution of errors. We can easily check this with a scatterplot with the predicted values on the x-axis, and residuals on the y-axis(see Figure \ref{fig:diagnostic} in the margin).

\begin{marginfigure}
<<fig.width = 3.5, fig.height = 3.5>>=
plot(x = result$fitted.values, 
     y = result$residuals,
     main = "Model Diagnostics")
@
\caption{We see no evidence for a relationship between predicted values and residuals. This is good!}
\label{fig:diagnostic}
\end{marginfigure}


\section{Generalized Linear Model (GLM)}

In the Generalized Linear Model (GLM), we take the original linear model, but apply a link function that wraps around the linear combination of predictors


\vspace{5mm} %5mm vertical space
\noindent
\setlength{\fboxrule}{1.5pt}
\fbox{
\parbox{\textwidth}{

\newfun{glm()}\index{glm()}

\hline

\begin{description}

\item[\tt{function, data, subset}] \hfill \\
The same arguments as in \texttt{lm()}

\item[\tt{family}] \hfill \\
  One of the following strings, indicating the link function for the general linear model
  
  \begin{itemize}
  \item "binomial": Binary logistic regression, useful when the response is either 0 or 1.
  \item "gaussian": Standard linear regression. Using this family will give you the same result as \texttt{lm()}
  \item "Gamma": Gamma regression, useful for exponential response data
  \item "inverse.gaussian": Inverse-Gaussian regression, useful when the dv is strictly positive and skewed to the right.
  \item "poisson": Poisson regression, useful for count data. For example, ``How many parrots has a pirate owned over his/her lifetime?"
  \end{itemize}
  
\end{description}

}
}
\vspace{5mm} %5mm vertical space


The key new argument in \texttt{glm()} compared to \texttt{lm()} is the \texttt{family} argument. This argument tells R which link function to use. To see more information about the families, look at help under \texttt{?family}.

\subsection{Binary Logistic Regression}

Probably the most common non-Normal family you will use is binomial which corresponds to binary logistic regression. In binary logistic regression, we predict a binary outcome variable (containing 0s and 1s) as the logit transformation of a linear combination of a set of predictors. Formally:

\begin{Large}
\begin{equation*}
p(y=1)=\frac{1}{1+e^{-(\beta_{0}+\beta_{1}x_{1}+\beta_{2}x_{2}+...\beta_{n}x_{n})}}
\end{equation*}
\end{Large}


\begin{marginfigure}
\begin{tiny}
<<fig.width = 4, fig.height = 4>>=
# Logit
logit.fun <- function(x) {1 / (1 + exp(-x))}

curve(logit.fun, 
      from = -3, 
      to = 3,
      lwd = 2, 
      main = "Logit",
      ylab = "p(y = 1)",
      xlab = expression("b_{0} + b_{1}x_{1} + b_{2}x_{2} + ... b_{n}x_{n}")
      )

abline(h = .5, lty = 2)
abline(v = 0, lty = 1)
@
\caption{The logit function used in binary logistic regression}
\label{fig:logit}
\end{tiny}
\end{marginfigure}


To conduct binary logistic regression, we use the \texttt{family = "binomial"} argument. Let's try an example with some more made-up data. We'll set the true beta values to 0, 1, -2 and 3

\begin{footnotesize}
<<>>=
# Step 1: Create a dataframe of predictors
random.data <- data.frame(
             "x1" = rnorm(500, mean = 0, sd = 2),
             "x2" = rnorm(500, mean = 4, sd = 2),
             "x3" = rnorm(500, mean = -2, sd = 2)
             )

# Step 2: Create the DV with beta values 0, 1, -2, 3
random.data$y <- with(random.data, 0 + 1 * x1 - 2 * x2 + 0 * x3)

# Step 3: Add some random noise to the DV
random.data$y <- random.data$y + rnorm(500, mean = 0, sd = 1)

# Step 4: Convert to probability
random.data$y.prob <- with(random.data, 1 / (1 + exp(-y)))

# Step 5: Create binary response
random.data$y.bin <- round(random.data$y.prob, 0)

# Step 4: Run the model then print the result
result <- glm(y.bin ~ x1 + x2 + x3,
              data = random.data, family = "binomial")

result

summary(result)
@
\end{footnotesize}


\section{ANOVA}

Once you've calculated a regression object, you can easily create an \textit{ANOVA} table based on the regression analysis using the \texttt{anova()} function.

\newfun{anova(mod)}\index{General Linear Model!anova()}

To use the \texttt{anova()} function, you apply it to an existing linear model object. For example, let's apply it to the previous model:

\begin{footnotesize}
<<>>=
anova(result)
@
\end{footnotesize}

Looks like we have significant effects for all predictors

%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{12: Writing your own functions (Coming Soon!)}
\label{ch:12}


\section{The basic structure of a function}
\section{Tips and tricks for complex functions}
\section{Storing and loading your functions to and from a function file}
%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{13: Loops and Simulations (Coming Soon!)}
\label{ch:13}

\section{When and when not to use loops}
\section{The list object}
\section{Simple loops over one index}
\section{Loops over multiple indices}
\section{Printing and saving temporary results}
\section{Parallel computing with snowfall()}

%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{14: Bayesian Inference (Coming Soon!)}
\label{ch:14}


\section{What are Bayesian statistics?}
\section{Bayesian one and two sample tests}
\section{Bayesian general linear model}


%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{15: Model fitting (Coming Soon!)}
\label{ch:15}


\section{What is a model?}
\section{What is a loss function?}
\section{Minimizing loss functions with optimization routines}
\section{A worked example: Prospect Theory}


%----------------------------------------------------------------------------------------
%	CHAPTER 9
%----------------------------------------------------------------------------------------

\chapter{16: Writing and sharing your work (Coming Soon!)}
\label{ch:16}

\section{RMarkdown}
\section{Shiny}
\section{Sweave (R and Latex)}


%----------------------------------------------------------------------------------------
%	CHAPTER 7
%----------------------------------------------------------------------------------------

\chapter{Appendix}
\label{ch:X}

\begin{figure*}[h]
\begin{footnotesize}
<<>>=
plot(1, xlim = c(0, 26), ylim = c(0, 26), 
     type = "n", main = "Named Colors", xlab = "", ylab = "",
     xaxt = "n", yaxt = "n")

rect(xleft = rep(1:26, each = 26)[1:length(colors())] - .5,
     ybottom = rep(26:1, times = 26)[1:length(colors())] - .5,
     xright = rep(1:26, each = 26)[1:length(colors())] + .5,
     ytop = rep(26:1, times = 26)[1:length(colors())] + .5,
     col = colors()
     )

text(x = rep(1:26, each = 26)[1:length(colors())],
     y = rep(26:1, times = 26)[1:length(colors())],
     labels = colors(), cex = .3
     )
@
\end{footnotesize}
\caption{The colors stored in \texttt{colors()}.}
\label{fig:colors}
\end{figure*}



\backmatter

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\bibliography{bibliography} % Use the bibliography.bib file for the bibliography
\bibliographystyle{plainnat} % Use the plainnat style of referencing

%----------------------------------------------------------------------------------------

\printindex % Print the index at the very end of the document

\end{document}